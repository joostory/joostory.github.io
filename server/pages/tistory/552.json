{"pageProps":{"post":{"id":"552","date":"2019. 2. 9. 14:59","title":"React Hooks","content":"<p><iframe style=\"display: block; margin: 10px auto 30px;\" src=\"https://www.youtube.com/embed/dpw9EHDh2bM\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" data-opengraph-url=\"https://www.youtube.com/watch?v=dpw9EHDh2bM\" data-opengraph-image=\"https://i.ytimg.com/vi/dpw9EHDh2bM/maxresdefault.jpg\" data-opengraph-title=\"React%20Today%20and%20Tomorrow%20and%2090%25%20Cleaner%20React%20With%20Hooks\"></iframe></p>\n<p>이 발표를 보고나서 <a href=\"https://twitter.com/dan_abramov\">Dan Abramov</a>에게 묘한 매력을 느꼈다. 영어도 잘 못하면서 팔로우를 시작했다. Reactjs에 대해서 이런저런 것을 많이 보게 되었다. 그리고 어느 덧 발표했던 기능이 정식출시했다. 이름은 <a href=\"https://reactjs.org/docs/hooks-intro.html\">React Hooks</a>다.</p>\n<h2>기본 개념</h2>\n<p><a href=\"https://reactjs.org/docs/hooks-intro.html#motivation\">Hooks소개의 Motivation</a>에도 말하고 있지만 Hooks의 기본 목적인 간결함이다. 다음의 코드는 Hooks를 사용한 코드다.</p>\n<pre><code>import React, { useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<p>이 코드가 얼마나 간결한 코드인가하면 Hooks를 사용하지 않은 다음의 코드를 보면 알 수 있다.</p>\n<pre><code>import React, { Component } from 'react';\n\nclass Example extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n\n    this.handleChangeCount = this.handleChangeCount.bind(this);\n  }\n\n  handleChangeCount() {\n    this.setState({\n      count: this.state.count + 1\n    })\n  }\n\n  render() {\n    const { count } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;p&gt;You clicked {count} times&lt;/p&gt;\n        &lt;button onClick={() =&gt; this.handleChangeCount()}&gt;\n          Click me\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n<p>동일한 동작을 하는 코드지만 뭔가 많이 길다. <code>count++</code>를 하기 위해서 함수를 만들고 <code>bind</code>도 한다. 그리고 <code>state.count</code>를 만들기 위해서 <code>constructor</code>도 만들고 아무 의미없는 <code>super(props)</code>도 넣어줘야 했다. <code>render</code>에서 <code>this</code>를 생략하기 위해서 <code>const</code>로 별도의 변수를 만들기도 했다. Hooks를 사용한 코드는 사용하지 않은 코드에서 count를 컨트롤 하기 위해 만들었던 14줄의 코드를 단 한 줄로 만들었다.</p>\n<pre><code>const [count, setCount] = useState(0);</code></pre>\n<p>여기서 사용한 <code>useState</code>가 바로 Hooks의 하나다.</p>\n<h2>useState</h2>\n<p><code>useState</code>는&nbsp;<code>component</code>의 <code>state</code>를 관리하기 위한 hook이다. <code>useState</code>의 코드만 놓고 보면 사실 이전과 크게 다르지 않은 것 같다. 하지만 사용에는 큰 차이가 있다. hooks를 사용할 때는 기본적으로 <code>component</code>를 <code>class</code>가 아닌 <code>function</code>으로 만든다. 그래서 <code>setState</code>를 하기 위한 handler도 필요없고 자연스레 handler를 <code>bind</code>할 필요도 없어진다. javascript의 클로저로 인해 어디서든 바로 <code>setState</code>에 값을 넘겨주면 된다. <code>state</code>값도 마찬가지다.</p>\n<pre><code>// before\nthis.state = { state: initialState };\nthis.setState({ state: newValue });\n\n// hooks\nconst [state, setState] = useState(initialState);\nsetState(newValue);</code></pre>\n<p>다른 유용한 hook들도 몇개 더 살펴보자.</p>\n<h2>useEffect</h2>\n<p><code>useEffect</code>는 쉽게 말해 <code>componentDidUpdate</code>라고 보면 된다. 다른 점은 <code>componentDidMount</code>, <code>componentWillUnmount</code>가 하는 일도 한다. 기본구조는 다음과 같다.</p>\n<pre><code>useEffect(() =&gt; {\n  // BODY\n\n  return () =&gt; {\n    // CLEAN-UP\n  };\n}, [TARGET]);</code></pre>\n<p><a href=\"https://reactjs.org/docs/react-component.html#the-component-lifecycle\">React Component의 lifecycle</a>상에서 언제 실행되는지를 보면 쉽게 무슨 일을 하는지 파악할 수 있다.</p>\n<ul>\n<li>Mounting에서는 <code>render</code>후에 <code>componentDidMount</code>가 실행된다. Hooks에서는 <code>BODY</code> 부분이 실행된다.</li>\n<li>Unmounting에서는 <code>componentWillUnmount</code>가 실행된다. Hooks에서는 <code>CLEAN-UP</code> 부분이 실행된다.</li>\n<li>Updating에서는 <code>render</code>후에 <code>componentDidUpdate</code>가 실행된다. Hooks에서는 <code>CLEAN-UP</code>이 실행된 후 <code>BODY</code>가 실행된다. Updating은 이전에도 그렇지만 <code>props</code>, <code>state</code>가 변경되면 수행된다.</li>\n</ul>\n<p>여기까지만 보면 <code>useEffect</code> 내부가 굉장히 커지고 복잡해질 것 같다. 하지만 <code>TARGET</code>으로 인해 이 복잡성이 크게 줄어든다. TARGET은 변경을 추적할 대상이다. 아래의 코드에서 첫번째 <code>useEffect</code>는 <code>count</code>라는 <code>state</code>값이 변경된 경우에만 동작한다. 두번째 <code>useEffect</code>는 <code>props.post.title</code> 값이 변경된 경우에만 동작한다. <code>TARGET</code>을 생략하면 모든 값에 대해서 동작한다.</p>\n<pre><code>useEffect(() =&gt; { ... }, [count]);\nuseEffect(() =&gt; { ... }, [props.post.title]);</code></pre>\n<p>물론 <code>componentDidUpdate</code>를 잘 사용하지않는 나로서는 조금 번거롭게 느껴지기도 한다.</p>\n<h2>useRef</h2>\n<p><code>useRef</code>는 <code>React.createRef</code>와 거의 같다. 다른 점은 <code>initialValue</code>를 사용할 수 있다는 점이다. 하지만 내가 사용하는 대부분의 경우 <code>ref</code>는 <code>container</code>와 <code>child</code>의 검증을 위해서 사용했다. 그래서 이게 있다고 <code>ref</code>를 <code>form</code>에 사용할 것 같지는 않다.</p>\n<h2>useReducer</h2>\n<p><code>useReducer</code>는 코드만 보면 <code>redux</code>에서 사용하던 <code>reducer</code>와 흡사하다. 하지만 이것은 <code>redux</code>가 아니다. 여러 컴포넌트에 <code>useReducer</code>로 만든 <code>reducer</code>를 같이 사용할 수 있다면 완전히 대체할 수도 있을 것 같다.</p>\n<pre><code>const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    &lt;&gt;\n      Count: {state.count}\n      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<hr>\n<p>정리한 것 외에도 <a href=\"https://reactjs.org/docs/hooks-reference.html\">여러가지 Hook</a>이 있고 <a href=\"https://reactjs.org/docs/hooks-custom.html\">hook을 만들 수도 있다</a>. 어쨌거나 코드 스타일을 OOP에서 Function으로 바꿔야 해서 좀 더 javascript다운 코드를 만들 수 있을 것 같고 무엇보다 간결한 코드를 만들 수 있을 것 같다. 테스트도 더 쉬워진 것 같다. 얼른 해보고 싶다.</p>\n<p>+ 추가: <a href=\"https://github.com/joostory/tistory-editor/commit/1f78ae01951e3894436e2f5364321de8777dda4f?diff=split\">몇개 변경해봤는데</a> 너무 좋다. redux를 어떻게 써야하는 지를 몰라서 일단 중단했는데 알아보고나서 더 해야겠다.&nbsp;</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://reactjs.org/blog/2019/02/06/react-v16.8.0.html\">https://reactjs.org/blog/2019/02/06/react-v16.8.0.html</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-overview.html\">https://reactjs.org/docs/hooks-overview.html</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html\">https://reactjs.org/docs/hooks-reference.html</a></li>\n</ul>            ","summary":"\n이 발표를 보고나서 Dan Abramov에게 묘한 매력을 느꼈다. 영어도 잘 못하면서 팔로우를 시작했다. Reactjs에 대해서 이런저런 것을 많이 보게 되었다. 그리고 어느 덧 발표했던 기능이 정식출시했다. 이름은 React Hooks다.\n기본 개념\nHooks소개의 Motivation에도 말하고 있지만 Hooks의 기본 목적인 간결함이다. 다음의 코드는 Hooks를 사용한 코드다.\n<code>import React, { useState } from ","image":"https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"}},"__N_SSG":true}