<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" href="/favicon.ico"/><meta name="description" content="JooStory.net"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><link rel="canonical" href="https://blog.joostory.net/564"/><title>hooks로 만드는 reducer</title><meta property="og:type" content="article"/><meta property="og:title" content="hooks로 만드는 reducer"/><meta property="og:description" content="react를 사용하는데 redux는 필수적인 요소라고 할 수 있다. 이제는 다른 방법들도 많은 것 같지만 결국 redux와 같이 app 전체에서 공유하는 공통 state를 사용하는 것은 비슷하다.
&lt;code&gt;import React, { Component } from &#x27;react&#x27;
import { connect } from &#x27;react-redux&#x27;
import { changeName } from &#x27;./actions&#x27;

@connect(state =&amp;gt;"/><meta property="og:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="hooks로 만드는 reducer"/><meta name="twitter:description" content="react를 사용하는데 redux는 필수적인 요소라고 할 수 있다. 이제는 다른 방법들도 많은 것 같지만 결국 redux와 같이 app 전체에서 공유하는 공통 state를 사용하는 것은 비슷하다.
&lt;code&gt;import React, { Component } from &#x27;react&#x27;
import { connect } from &#x27;react-redux&#x27;
import { changeName } from &#x27;./actions&#x27;

@connect(state =&amp;gt;"/><meta property="twitter:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/11ae7950df9656c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/11ae7950df9656c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f76bbe1730ea85a1.js" defer=""></script><script src="/_next/static/chunks/494-fa03e5491fc3b3a9.js" defer=""></script><script src="/_next/static/chunks/pages/tistory/%5Bid%5D-571a42114028488a.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_buildManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_ssgManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class=""><div class="pt-40 pb-36 px-20 border-b-[1px] relative"><h1 class="font-bold tracking-tighter leading-tight md:leading-none mb-4 text-center text-3xl">hooks로 만드는 reducer</h1><div class="flex justify-center"><em class="text-sm"><time dateTime="2019. 5. 6. 10:02">2019. 5. 6. 10:02</time></em></div></div><div class="w-[650px] pt-10 pb-20 mx-auto"><article class="prose"><p>react를 사용하는데 redux는 필수적인 요소라고 할 수 있다. 이제는 다른 방법들도 많은 것 같지만 결국 redux와 같이 app 전체에서 공유하는 공통 state를 사용하는 것은 비슷하다.</p>
<pre id="code_1557102031211" class="javascript" data-ke-type="codeblock"><code>import React, { Component } from 'react'
import { connect } from 'react-redux'
import { changeName } from './actions'

@connect(state =&gt; ({
	name: state.name
}), dispatch =&gt; ({
	handleChangeName: (name) =&gt; {
    dispatch(changeName(name))
  }
}))
class MyComponent extends Component {

  constructor(props) {
    super(props)
    this.handleChange = this.handleChange.bind(this)
  }
    
  handleChange(e) {
    const { handleChangeName } = this.props
    handleChangeName(e.target.value)
  }
	
  render() {
    const { name } = this.props
    return (
      &lt;div&gt;
        Hello,
        &lt;input
          type='text'
          value={name}
          onChange={this.handleChange}
        /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>그 동안의 component는 이런 식으로 es 클래스로 만들었는데 react 16.8에서 등장한 hooks 때문에 이 모습은 많이 바뀌었다. 먼저 component를 class 대신 function으로 만드는 것이 기본 형태가 되었다. 내부 method에 bind를 하는 대신 직접 호출할 수 있게 되었고, setState 대신 set으로 직접 값을 변경하는 등 객체지향적인 모습을 많이 벗어버리고 좀 더 javascript 본연의 모습과 가깝게 되었다.</p>
<p>component가 훨씬 간결해지고 직관적으로 변화되었지만 쉽사리 변경하지 못하는 문제가 있었다. 바로 redux다. 위의 코드만 하더라도 decorator를 사용한 connect는 그리 거슬리지 않는다. 하지만 일전에 정리한 <a href="https://blog.joostory.net/562" target="_blank" rel="noopener">functional component에 redux를 적용하는 방법</a>만 하더라도 별로 좋아보이지 않는다. 이왕이면 hooks를 사용하면 좋았을텐데 방법이 없었다.</p>
<h2>useReducer 사용</h2>
<p>어떻게든 hooks를 사용해서 이 문제를 해결해보고 싶었다. 그래서 useReducer를 사용해봤다. <a href="https://reactjs.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">useReducer</a>는 redux에서 제공하는 state, dispatch를 거의 유사하게 제공한다. 하지만 전역으로 사용하기 위해서는 이 state, dispatch를 제공하는 store가 공유되어야 하는데 그게 안된다. 그래서 Context api를 사용해서 해결해보고자 했다.</p>
<pre id="code_1557103888789" class="javascript" data-ke-type="codeblock"><code>export const initialState = { ... }
export const AppContext = createContext(initialState);
export function reducer(state = initialState, action) { ... }

export default function(props) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
      &lt;AppContext.Provider value={{state, dispatch}}&gt;
        &lt;div className={classes.root}&gt;
          &lt;Header /&gt;
          &lt;Content /&gt;
        &lt;/div&gt;
      &lt;/AppContext.Provider&gt;
  );
}</code></pre>
<p>어떻게 되긴한다. Provider에 state, dispatch를 넘겨주고 Consumer에서 getContext로 이걸 사용하니까 잘된다. 근데 문제는 getContext에 context를 넘겨주기 위해서 만든 AppContext를 export해서 사용해야했고 redux에서 제공하는 combineReducer 같은 기능은 제공하지 않기 때문에 reducer에 많은 데이터를 넣기가 부담이 된다.</p>
<p>useReducer는 아무래도 component 하나에서 state를 효과적으로 관리하는 용도로만 사용해야할 것 같다. 아무래도 state를 컨트롤하는 로직이 component에서 분리될테니 좀 더 간결한 component 생성이 가능할 것이다. 그럼 hooks로 데이터 관리는 포기하고&nbsp; connect를 사용해야 하느냐 다시 원점으로 돌아온다.</p>
<h2>react-redux의 hooks</h2>
<p>이전에는 react-redux에서 hooks를 제공하지 않았다. 그런데 7.1.0-alpha 버전에서 hooks에 대한 개발과 테스트가 한창이다. <a href="https://github.com/reduxjs/react-redux/issues/1063" target="_blank" rel="noopener">useRedux</a>를 썼다가 <a href="https://github.com/reduxjs/react-redux/issues/1252#issuecomment-488160930" target="_blank" rel="noopener">useActions를 썼다가 alpha4 버전에서 useSelector, useDispatch로 정리되는 분위기</a>다. 언제 나오나 언제 나오나 했는데 곧 나올 분위기다. 하지만 아직 alpha이고api가 생겼다 없어졌다 마구 바뀌고 있어서 언제 나올지 확신할 수는 없다. 그래도 궁금하니 소소한 프로젝트에 한번 써보기로 했다.</p>
<pre id="code_1557162592425" class="javascript" data-ke-type="codeblock"><code>  const user = useSelector(state =&gt; state.user)
  const dispatch = useDispatch()

  useEffect(() =&gt; {
    axios.get('/api/user')
      .then(res =&gt; {
        dispatch(updateUser(res.data.user));
      })
  }, []);</code></pre>
<p>기존에 사용하던 connect 의 첫번째 파라미터는 useSelector로, 두번째 파라미터는 useDispatch로 생각하면 편하다. state의 각 값마다 useSelector를 사용해줘야 한다는 점은 약간 번거로울 수 있지만 그래도 그 편이 더 직관적이다. action을 dispatch할때 주로 한번 감싸서 props에 넣어줬는데 dispatch를 직접 받아서 action을 처리하는 것도 괜찮은 것 같다.</p>
<p>써보니 더 좋은 것 같다. Context api는 redux를 완전히 대체하지 못할 것 같고 언뜻 이해가 안되던 hoc 방식의 connect를 hooks로 바꾸니 알기가 쉬워졌다. 어서 7.1이 정식 릴리즈되면 좋겠다. 이제는 완전히 class를 벗어나서 functional component로 전환할 수 있을 것 같다.</p>
<p>&nbsp;</p>            </article></div></div></main></div><footer class="bg-slate-100 border-t border-accent-2 mt-6"><div class="py-4 flex flex-col items-center justify-center text-xs text-slate-500"><a href="https://twitter.com/@JooStory">@JooStory</a></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"564","date":"2019. 5. 6. 10:02","title":"hooks로 만드는 reducer","content":"\u003cp\u003ereact를 사용하는데 redux는 필수적인 요소라고 할 수 있다. 이제는 다른 방법들도 많은 것 같지만 결국 redux와 같이 app 전체에서 공유하는 공통 state를 사용하는 것은 비슷하다.\u003c/p\u003e\n\u003cpre id=\"code_1557102031211\" class=\"javascript\" data-ke-type=\"codeblock\"\u003e\u003ccode\u003eimport React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { changeName } from './actions'\n\n@connect(state =\u0026gt; ({\n\tname: state.name\n}), dispatch =\u0026gt; ({\n\thandleChangeName: (name) =\u0026gt; {\n    dispatch(changeName(name))\n  }\n}))\nclass MyComponent extends Component {\n\n  constructor(props) {\n    super(props)\n    this.handleChange = this.handleChange.bind(this)\n  }\n    \n  handleChange(e) {\n    const { handleChangeName } = this.props\n    handleChangeName(e.target.value)\n  }\n\t\n  render() {\n    const { name } = this.props\n    return (\n      \u0026lt;div\u0026gt;\n        Hello,\n        \u0026lt;input\n          type='text'\n          value={name}\n          onChange={this.handleChange}\n        /\u0026gt;\n      \u0026lt;/div\u0026gt;\n    )\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 동안의 component는 이런 식으로 es 클래스로 만들었는데 react 16.8에서 등장한 hooks 때문에 이 모습은 많이 바뀌었다. 먼저 component를 class 대신 function으로 만드는 것이 기본 형태가 되었다. 내부 method에 bind를 하는 대신 직접 호출할 수 있게 되었고, setState 대신 set으로 직접 값을 변경하는 등 객체지향적인 모습을 많이 벗어버리고 좀 더 javascript 본연의 모습과 가깝게 되었다.\u003c/p\u003e\n\u003cp\u003ecomponent가 훨씬 간결해지고 직관적으로 변화되었지만 쉽사리 변경하지 못하는 문제가 있었다. 바로 redux다. 위의 코드만 하더라도 decorator를 사용한 connect는 그리 거슬리지 않는다. 하지만 일전에 정리한 \u003ca href=\"https://blog.joostory.net/562\" target=\"_blank\" rel=\"noopener\"\u003efunctional component에 redux를 적용하는 방법\u003c/a\u003e만 하더라도 별로 좋아보이지 않는다. 이왕이면 hooks를 사용하면 좋았을텐데 방법이 없었다.\u003c/p\u003e\n\u003ch2\u003euseReducer 사용\u003c/h2\u003e\n\u003cp\u003e어떻게든 hooks를 사용해서 이 문제를 해결해보고 싶었다. 그래서 useReducer를 사용해봤다. \u003ca href=\"https://reactjs.org/docs/hooks-reference.html#usereducer\" target=\"_blank\" rel=\"noopener\"\u003euseReducer\u003c/a\u003e는 redux에서 제공하는 state, dispatch를 거의 유사하게 제공한다. 하지만 전역으로 사용하기 위해서는 이 state, dispatch를 제공하는 store가 공유되어야 하는데 그게 안된다. 그래서 Context api를 사용해서 해결해보고자 했다.\u003c/p\u003e\n\u003cpre id=\"code_1557103888789\" class=\"javascript\" data-ke-type=\"codeblock\"\u003e\u003ccode\u003eexport const initialState = { ... }\nexport const AppContext = createContext(initialState);\nexport function reducer(state = initialState, action) { ... }\n\nexport default function(props) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n      \u0026lt;AppContext.Provider value={{state, dispatch}}\u0026gt;\n        \u0026lt;div className={classes.root}\u0026gt;\n          \u0026lt;Header /\u0026gt;\n          \u0026lt;Content /\u0026gt;\n        \u0026lt;/div\u0026gt;\n      \u0026lt;/AppContext.Provider\u0026gt;\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어떻게 되긴한다. Provider에 state, dispatch를 넘겨주고 Consumer에서 getContext로 이걸 사용하니까 잘된다. 근데 문제는 getContext에 context를 넘겨주기 위해서 만든 AppContext를 export해서 사용해야했고 redux에서 제공하는 combineReducer 같은 기능은 제공하지 않기 때문에 reducer에 많은 데이터를 넣기가 부담이 된다.\u003c/p\u003e\n\u003cp\u003euseReducer는 아무래도 component 하나에서 state를 효과적으로 관리하는 용도로만 사용해야할 것 같다. 아무래도 state를 컨트롤하는 로직이 component에서 분리될테니 좀 더 간결한 component 생성이 가능할 것이다. 그럼 hooks로 데이터 관리는 포기하고\u0026nbsp; connect를 사용해야 하느냐 다시 원점으로 돌아온다.\u003c/p\u003e\n\u003ch2\u003ereact-redux의 hooks\u003c/h2\u003e\n\u003cp\u003e이전에는 react-redux에서 hooks를 제공하지 않았다. 그런데 7.1.0-alpha 버전에서 hooks에 대한 개발과 테스트가 한창이다. \u003ca href=\"https://github.com/reduxjs/react-redux/issues/1063\" target=\"_blank\" rel=\"noopener\"\u003euseRedux\u003c/a\u003e를 썼다가 \u003ca href=\"https://github.com/reduxjs/react-redux/issues/1252#issuecomment-488160930\" target=\"_blank\" rel=\"noopener\"\u003euseActions를 썼다가 alpha4 버전에서 useSelector, useDispatch로 정리되는 분위기\u003c/a\u003e다. 언제 나오나 언제 나오나 했는데 곧 나올 분위기다. 하지만 아직 alpha이고api가 생겼다 없어졌다 마구 바뀌고 있어서 언제 나올지 확신할 수는 없다. 그래도 궁금하니 소소한 프로젝트에 한번 써보기로 했다.\u003c/p\u003e\n\u003cpre id=\"code_1557162592425\" class=\"javascript\" data-ke-type=\"codeblock\"\u003e\u003ccode\u003e  const user = useSelector(state =\u0026gt; state.user)\n  const dispatch = useDispatch()\n\n  useEffect(() =\u0026gt; {\n    axios.get('/api/user')\n      .then(res =\u0026gt; {\n        dispatch(updateUser(res.data.user));\n      })\n  }, []);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존에 사용하던 connect 의 첫번째 파라미터는 useSelector로, 두번째 파라미터는 useDispatch로 생각하면 편하다. state의 각 값마다 useSelector를 사용해줘야 한다는 점은 약간 번거로울 수 있지만 그래도 그 편이 더 직관적이다. action을 dispatch할때 주로 한번 감싸서 props에 넣어줬는데 dispatch를 직접 받아서 action을 처리하는 것도 괜찮은 것 같다.\u003c/p\u003e\n\u003cp\u003e써보니 더 좋은 것 같다. Context api는 redux를 완전히 대체하지 못할 것 같고 언뜻 이해가 안되던 hoc 방식의 connect를 hooks로 바꾸니 알기가 쉬워졌다. 어서 7.1이 정식 릴리즈되면 좋겠다. 이제는 완전히 class를 벗어나서 functional component로 전환할 수 있을 것 같다.\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e            ","summary":"react를 사용하는데 redux는 필수적인 요소라고 할 수 있다. 이제는 다른 방법들도 많은 것 같지만 결국 redux와 같이 app 전체에서 공유하는 공통 state를 사용하는 것은 비슷하다.\n\u003ccode\u003eimport React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { changeName } from './actions'\n\n@connect(state =\u0026gt;","image":"https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"}},"__N_SSG":true},"page":"/tistory/[id]","query":{"id":"564"},"buildId":"k2SjylS4DhAPzPoZgQ49x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>