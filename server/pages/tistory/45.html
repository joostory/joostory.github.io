<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" href="/favicon.ico"/><meta name="description" content="JooStory.net"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><link rel="canonical" href="https://blog.joostory.net/45"/><title>Unix Programming Environment 정리</title><meta property="og:type" content="article"/><meta property="og:title" content="Unix Programming Environment 정리"/><meta property="og:description" content="책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.
1장 초보자를 위한 Unix
1.1 출발
단말기와 타이핑
제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)
tty : teletype, terminal의 동의어
단말기의 이상동작
stty : set terminal options
stty -tabs
오타
return을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 "/><meta property="og:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Unix Programming Environment 정리"/><meta name="twitter:description" content="책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.
1장 초보자를 위한 Unix
1.1 출발
단말기와 타이핑
제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)
tty : teletype, terminal의 동의어
단말기의 이상동작
stty : set terminal options
stty -tabs
오타
return을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 "/><meta property="twitter:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/11ae7950df9656c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/11ae7950df9656c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f76bbe1730ea85a1.js" defer=""></script><script src="/_next/static/chunks/494-fa03e5491fc3b3a9.js" defer=""></script><script src="/_next/static/chunks/pages/tistory/%5Bid%5D-571a42114028488a.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_buildManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_ssgManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class=""><div class="pt-40 pb-36 px-20 border-b-[1px] relative"><h1 class="font-bold tracking-tighter leading-tight md:leading-none mb-4 text-center text-3xl">Unix Programming Environment 정리</h1><div class="flex justify-center"><em class="text-sm"><time dateTime="2008. 3. 25. 15:39">2008. 3. 25. 15:39</time></em></div></div><div class="w-[650px] pt-10 pb-20 mx-auto"><article class="prose">책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.
<h2>1장 초보자를 위한 Unix</h2>
<h3>1.1 출발</h3>
<p>단말기와 타이핑</p>
<p style="margin-left: 2em;">제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)</p>
<p style="margin-left: 2em;">tty : teletype, terminal의 동의어</p>
<p>단말기의 이상동작</p>
<p style="margin-left: 2em;">stty : set terminal options</p>
<p style="margin-left: 2em;">stty -tabs</p>
<p>오타</p>
<p style="margin-left: 2em;">return을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 이전 입력문자를 버린다. (현재는 ^U를 사용한다.)</p>
<p style="margin-left: 2em;">#를 누르면 이전 입력문자 1개를 버린다. (현재의 삭제와 같다.)</p>
<p>우편 사용하기</p>
<p style="margin-left: 2em;">mail을 사용하면 현재 사용자에게 메일을 보낼 수 있다.</p>
<p style="margin-left: 2em;">write를 사용하여 terminal상의 사용자에게 message를 보낼 수 있다.</p>
<h3>1.2 화일과 자주 쓰는 명령어</h3>
<p>편집기 ed</p>
<p style="margin-left: 2em;">a : 입력시작 append</p>
<p style="margin-left: 2em;">. : 입력 종료</p>
<p style="margin-left: 2em;">w filename : 파일에 저장</p>
<p style="margin-left: 2em;">q : 종료</p>
<p style="margin-left: 2em;">n,mp : n-m줄까지 print 하라 $는 마지막 줄</p>
<p>화일의 프린트 - cat and pr</p>
<p style="margin-left: 2em;">cat 은 화일을 화면에 출력한다.</p>
<p style="margin-left: 2em;">pr 은 프린트 가능한 형태로 보여준다.</p>
<p style="margin-left: 4em;">pr -n : n개의 단으로 나누어 보여준다.</p>
<p style="margin-left: 2em;">pr 과 lpr은 보통 같이 사용된다. nroff, troff 등의 프린트 명령이 있다.</p>
<p>유용한 명령들</p>
<p style="margin-left: 2em;">wc : 단어 세기</p>
<p style="margin-left: 2em;">grep : 찾기</p>
<p style="margin-left: 2em;">sort : 문자 정렬</p>
<p style="margin-left: 4em;">-r : reverse</p>
<p style="margin-left: 4em;">-n : 숫자 순으로 정렬 -nr 도 가능</p>
<p style="margin-left: 4em;">-f : 대소문자 구분 x</p>
<p style="margin-left: 4em;">+n : n+1번째부터</p>
<p style="margin-left: 2em;">tail : 마지막 열을 기준으로 출력</p>
<p style="margin-left: 2em;">cmp file1 file2 : 차이점 비교 (대부분 같은지를 확인할 때 사용)</p>
<p style="margin-left: 2em;">diff file1 file2 : 차이점 비교 (다름을 알고 어떻게 다른지 알고자 할 때 사용)</p>
<h3>1.3 디렉토리</h3>
<p>특별히 정리할 만한 내용이 없다.</p>
<h3>1.4 쉘</h3>
<p>쉘에서는 패턴을 사용할 수 있다.</p>
<p style="margin-left: 2em;">패턴을 사용치 않으려면 ' 나 \를 사용하면된다.</p>
<p>입출력 방향전환</p>
<p style="margin-left: 2em;">&gt; : 왼쪽의 출력을 오른쪽의 입력으로 전환한다. &lt; 는 반대</p>
<p style="margin-left: 2em;">&gt;&gt; : 동일하나 추가의 의미</p>
<p>파이프</p>
<p style="margin-left: 2em;">&gt; 가 표준입력을 전달했다면 | 는 인자를 전달한다.</p>
<p>프로세스</p>
<p style="margin-left: 2em;">&amp; : background 로 실행하라</p>
<p style="margin-left: 2em;">파이프로 연결된 명령에 &amp; 를 사용하면 모든 명령이 동시에 background로 전환되지만 마지막 PID만이 프린트된다.</p>
<p style="margin-left: 2em;">wait : &amp; 로 시작된 모든 프로세스를 기다린다.</p>
<p style="margin-left: 2em;">nohup : "no hangup" 단말기가 로그아웃이 되더라도 명령을 계속 동작시킨다. 해당 명령의 출력은 nohup.out 에 저장된다.</p>
<p style="margin-left: 2em;">nice : 프로세스의 순위를 변경한다. nohup은 실행되면 nice를 사용하여 실행하는 프로세스의 순위를 낮춘다. (로그아웃할 것이므로)</p>
<p style="margin-left: 2em;">at : 명령 수행 시간을 지정할 수 있다. (시간 형태 : 0000 or 0000(a|p)m</p>
<p style="margin-left: 4em;">$ at 시간</p>
<p style="margin-left: 4em;">명령어들...</p>
<p style="margin-left: 4em;">^D</p>
<p style="margin-left: 4em;">$</p>
<p>환경꾸미기</p>
<p style="margin-left: 2em;">후진키 사용</p>
<p style="margin-left: 4em;">stty erase '^h"</p>
<p style="margin-left: 2em;">프롬프트 사용 (PS1 변수를 변경하면 된다.)</p>
<p style="margin-left: 4em;">PS1='Prompt $'</p>
<p style="margin-left: 2em;">export 변수 : 쉘에게 변수 알리기</p>
<h2>2장 화일 시스템</h2>
<p>Unix 시스템에서는 모든 것이 화일이다.</p>
<h3>2.1 화일의 기본 사항</h3>
<p>od : (octal dump) 화일의 모든 바이트를 사용자가 볼 수 있도록 한다.</p>
<p style="margin-left: 2em;">od -c : 문자로 보이기</p>
<p style="margin-left: 2em;">od -b : 각 바이트를 8진수로 보여준다.</p>
<p>개행문자에 대한 터미널의 해석</p>
<p style="margin-left: 2em;">\n 은 od 같은 프로그램이 사용하는 관십의 표현이며 실제는 한 바이트인 8진수 012로 저장된다.</p>
<p style="margin-left: 2em;">탭 같은 경우도 터미널이 문자를 보고 해석하여 화면에 뿌려주는데 커널이 하도록 할 수 있다. stty -tabs는 커널이 탭을 공백문자로 바꾼다.</p>
<p style="margin-left: 2em;">개행문자로 마찬가지이다. 012를 캐리지 리턴과 개행으로 확장하여 출력한다. 일부 시스템(windows, joo생각)은 CRLF를 직접 파일에 입력한다. Unix에서는 사용자가 화일에 넣지 않은 어떠한 바이트도 사용하지 않는다.</p>
<h3>2.2 화일의 내용</h3>
<p>Unix 에서는 화일은 구별하려는 대신 화일의 차이점을 무시하려고 한다. 모든 화일은 문자와 개행문자로 구성된다. Unix에서는 화일에 접근하기 위해서는 단지 화일 이름만 알면 된다.</p>
<p>그러나 이것은 문제가 될 수 있다. 이진화일의 경우 개행문자 없이 수만문자가 이어져 나온다. 이 경우 Unix 프로그램은 제대로 수행되지 못한다. 한 줄에 대한 가상의 정의가 되어 있기 때문이다.</p>
<h3>2.3 디렉토리와 화일명</h3>
<p>pwd : 현재의 디렉토리를 알려준다.</p>
<p>du : 한 디렉토리 내의 모든 화일과 모든 부디렉토리가 차지하는 디스크 공간의 양을 알려준다.</p>
<h3>2.4 접근권한</h3>
<p>화일에 접근권한을 두어서 다른 사용자가 자신의 화일을 볼 수 없도록 할 수 있다.</p>
<p>su를 사용해 수퍼유저이 될 수 있다. 이 경우 모든 화일에 접근할 수 있는데 수퍼유저도 볼 수 없는 화일을 만들기 위해 crypt를 사용할 수 있다.</p>
<p>/etc/passwd : 로그인정보를 포함해 암호정보를 가지고 있다.</p>
<p>set-uid : 화일권한에 x 대신 s가 있는 것은 화일이 실행되는 순간 그 화일의 소유자의 권한이 되는 것이다. 이것은 매우 유용하지만 잘못 사용하면 보안상의 문제가 생길 수 있다.</p>
<h3>2.5 i-노드</h3>
<p>inode에는 세가지 시간이 있다.</p>
<p style="margin-left: 2em;">최종수정시간 : 쓰여진 시간</p>
<p style="margin-left: 2em;">최종사용시간 : 읽거나 수행된 시간</p>
<p style="margin-left: 2em;">최종변경시간 : inode가 변경된 시간</p>
<p>chmod, chown</p>
<h3>2.6 디렉토리 계층</h3>
<p>/bin : binaries</p>
<p>/dev : devices</p>
<p>/etc : et cetera</p>
<h3>2.7 장치</h3>
<p>/dev 에 있는 화일은 device로 사용되지만 Unix에는 동일하게 화일로 인식된다.</p>
<h2>3장 쉘의 사용</h2>
<h3>3.1 명령어 줄의 구조</h3>
<p>보통은 개행문자가 명령의 끝으로 인식되지만 ; 도 명령의 끝으로 인식된다.</p>
<p>; 로 구분된 명령을 파이프로 보낼때는 마지막 명령의 결과만이 파이프로 보내진다.</p>
<p>같이 보내기 위해서는 ()로 묶어주어야 한다.</p>
<p>tee : 파이프로 흐르는 data를 화일로 저장하고 파이프로 그대로 흘려보낼 수 있다.</p>
<h3>3.2 메타문자</h3>
<p>* 과 같은 특수한 특성을 가진 문자</p>
<p>이들 메타문자가 해석되지 않도록 하기 위해서는 ' 로 감싸주면 된다.</p>
<p>줄 끝의 역슬래쉬는 그 줄이 다음줄에 계속 연결되는 것을 말한다.</p>
<p>echo는 명시적으로 요청받지 않아도 최종적으로 개행문자를 출력한다.</p>
<p style="margin-left: 2em;">echo -n , echo "....\c" : 개행문자를 추가하지 않게 한다.</p>
<h3>3.3 새 명령어의 생성</h3>
<p>Unix의 여러가지 명령을 조합하여 새로운 명령을 만들 수 있다.</p>
<p>실행권한을 주게되면 쉘의 도움없이도 가능하다.</p>
<h3>3.4 명령어 인수 및 매개변수</h3>
<p>$1 ... $9 로 입력된 인자와 매개변수를 전달할 수 있다.</p>
<p>$* : 인자 모두를 뜻한다.</p>
<p style="margin-left: 2em;">echo 'grep $* /usr/you/lib/phone-book' &gt; 114 로 114 명령을 만들 수 있는데..</p>
<p style="margin-left: 2em;">114 'john mike' 에는 실제로 mike라는 화일에서 john을 찾는 것으로 해석될 수 있다.</p>
<p style="margin-left: 2em;">따라서 $* 를 "$*" 과 같이 " 로 감싸줄 필요가 있다.</p>
<p>$0 : 현재 수행되는 프로그램 이름이다.</p>
<h3>3.5 인수로서의 프로그램 출력</h3>
<p>` 로 감싼 부분은 수행된 뒤 그 결과를 반환한다.</p>
<p>pick : 대화식 명령이 가능하다.</p>
<h3>3.6 쉘 변수</h3>
<p>set : 모든 정의된 변수의 값을 알 수 있다. (몇가지를 보기위해서는 echo를 쓰는 것이 더 좋다)</p>
<p>HOME, PATH 등이 쉘에서 사용된다.</p>
<p>어떤 변수의 값을 부속쉘에서도 접근가능하게 하려면 export를 쓰면 된다.</p>
<h3>3.7 I/O 방향전환에 대한 추가 사항</h3>
<p>&gt; : 표준출력을 다른 곳으로 돌린다.</p>
<p>2&gt; : 표준에러를 다른 곳으로 돌린다.</p>
<p>2&gt;&amp;1 : 표준에러를 표준출력과 같은 곳으로 한다.</p>
<p>&lt;&lt; s : (here docuement) s를 맨앞에 가진 줄 직전까지의 표준입력을 취한다.</p>
<h3>3.8 쉘 프로그램에서의 반복문 처리</h3>
<p>for 변수 in 단어들의 목록</p>
<p>do</p>
<p style="margin-left: 2em;">명령어들</p>
<p>done</p>
<p>for 변수 in 목록 ; do 명령어들 ; done</p>
<p>for i in * 과 for i in $* 은 다르게 해석된다. 파일에서 $*로 사용하면 인자를 받아서 따로따로 수행하는 것이다.</p>
<h3>3.9 bundle : 모두 하나로 묶기</h3>
<p>bundle은 현재 사용되지 않는다.</p>
<h3>3.10 왜 하필이면 프로그램이 가능한 쉘인가?</h3>
<p>쉘은 프로그램으로 처리해야 하는 여러가지 문제를 해결해주기 때문에 이를 사용하는 것이 유익하다.</p>
<h2>4장 필터</h2>
<p>sed : stream editor</p>
<p>awk : 제작자의 이름을 따서 만들었다.</p>
<h3>4.1 grep 류</h3>
<p>$ grep 패턴 화일명들 ...</p>
<p>grep, egrep, fgrep</p>
<h3>4.2 그 밖의 필터들</h3>
<p>sort : 입력을 줄 단위로 아스키 순으로 정렬한다.</p>
<p>uniq : 중복된 줄을 버린다. (-c 로 중복된 횟수를 셀 수 있다)</p>
<p>comm : 화일을 비교한다.</p>
<p>tr : 입력의 문자를 변경할 수 있다. (대소문자 변환에 흔히 쓰인다)</p>
<h3>4.3 스트림 편집기 sed</h3>
<p>sed 는 ed를 고쳐서 사용되었다.</p>
<p>$ sed 'ed의 명령어' files...</p>
<p>명령</p>
<p style="margin-left: 2em;">'s/A/B/f' : substitute A to B, f=g 이면 모두 바꿈</p>
<p style="margin-left: 2em;">'y/A/B/' : A스트링을 B스트링으로 바꾸라</p>
<p style="margin-left: 2em;">-f file : 패턴을 파일로부터 읽어들인다.</p>
<p style="margin-left: 2em;">-n : 자동 프린트를 하지 않는다. 명시적으로 p를 사용해야 프린트한다.</p>
<p style="margin-left: 2em;">'/pattern/d' : 매칭되는 줄을 삭제</p>
<h3>4.4 패턴의 조사 처리 언어 awk</h3>
<p>$ awk '프로그램' files ...</p>
<p>프로그램</p>
<p style="margin-left: 2em;">pattern { action }</p>
<p>awk는 한번에 한 줄씩 화일명들에서 입력을 읽어들인다.</p>
<p>필드</p>
<p style="margin-left: 2em;">awk는 각 입력 줄을 자동으로 필드로 나눈다. $1 .. $NF(마지막 필드)</p>
<p style="margin-left: 2em;">-F분리자 : 분리자를 지정한다. (FS="분리자" 로도 쓸 수 있다)</p>
<p>프린트하기</p>
<p style="margin-left: 2em;">NR : 현제 레코드번호 (= 줄번호)</p>
<p style="margin-left: 2em;">printf "format" : printf 를 사용해 출력할 수 있다.</p>
<p>패턴</p>
<p style="margin-left: 2em;">== : 같다.</p>
<p style="margin-left: 2em;">~ : 문자와 부합된다.</p>
<p style="margin-left: 2em;">!~ : 문자와 부합되지 않는다.</p>
<p>BEGIN 및 END 패턴</p>
<p style="margin-left: 2em;">BEGIN { ... } : 입력을 읽기 전에 수행된다.</p>
<p style="margin-left: 2em;">END { ... } : 입력을 읽은 후 수행된다.</p>
<p>산술과 변수 : awk의 진정한 강점은 입력 데이타에 대한 계산이 가능하다는데에 있다.</p>
<p style="margin-left: 2em;">awk는 C와 동일한 산술연산을 사용할 수 있다.</p>
<p>awk의 내장 변수</p>
<p style="margin-left: 2em;">FILENAME : 현재의 입력 화일명</p>
<p style="margin-left: 2em;">FS : 필드 분리 문자</p>
<p style="margin-left: 2em;">NF : 입력 레코드 내의 필드 수</p>
<p style="margin-left: 2em;">NR : 입력 레코드 수</p>
<p style="margin-left: 2em;">OFMT : 숫자의 출력 포맷</p>
<p style="margin-left: 2em;">OFS : 출력 필드의 분리 문자열</p>
<p style="margin-left: 2em;">ORS : 출력 레코드의 분리 문자열</p>
<p style="margin-left: 2em;">RS : 입력 레코드 분리 문자</p>
<p>제어흐름</p>
<p style="margin-left: 2em;">C의 문법과 비슷하나 한 명령의 끝을 개행문자로 한다.</p>
<p style="margin-left: 2em;">next : 다음 입력 줄을 불러들인다.</p>
<p style="margin-left: 2em;">exit : END 패턴으로 즉각 넘어간다.</p>
<p>배열</p>
<p style="margin-left: 2em;">선언하지않고 배열이 사용이 가능하다.</p>
<p>awk의 내장함수</p>
<p style="margin-left: 2em;">cos(expr) : cosine</p>
<p style="margin-left: 2em;">exp(expr) : 지수</p>
<p style="margin-left: 2em;">getline() : 다음 입력 줄을 읽고 화일의 끝이면 0, 아니면 1일 반환</p>
<p style="margin-left: 2em;">index(s1, s2) : s1에서 문자열 s2의 위치, 없으면 0</p>
<p style="margin-left: 2em;">int(expr) : expr의 정수부, 버림법을 사용한다.</p>
<p style="margin-left: 2em;">length(s) : 문자열 s의 길이</p>
<p style="margin-left: 2em;">log(expr) : 자연로그</p>
<p style="margin-left: 2em;">sin(expr) : sine</p>
<p style="margin-left: 2em;">split(s, a, c) : s를 문자 c를 기준으로 a[1] ... a[n]으로 분리하고 n을 반환</p>
<p style="margin-left: 2em;">sprintf(fmt, ...) : fmt에 따른 포맷</p>
<p style="margin-left: 2em;">substr(s, m, n) : s내의 위치 m에서 시작하는 n 길이의 문자열</p>
<p>연관배열 : awk는 해쉬를 이용해 연관배열을 사용한다.</p>
<p>문자열</p>
<p style="margin-left: 2em;">a = a " " : awk에는 문자열 접합연산자가 특별히 없다. 단지 나열만으로 접합이 일어난다.</p>
<p>쉘과의 대화</p>
<p style="margin-left: 2em;">awk에서 인자를 받기위해서는 두가지 방식이 있다.</p>
<p style="margin-left: 4em;">awk '{ print $'$1' }'</p>
<p style="margin-left: 4em;">awk '{ print \$$1 }'</p>
<p style="margin-left: 2em;">따옴표를 사용하는 방법이 더 좋다. \가 너무 많아지면 복잡해지기 때문이다.</p>
<p style="margin-left: 2em;">또한 BEGIN을 통해 자주 사용되는 부분을 변수화 해두면 복잡함을 줄일 수 있다.</p>
<h3>4.5 좋은 화일과 좋은 필터</h3>
<p>Unix에서 생성하는 출력은 다른 프로그램의 입력으로 쓰일 수 있다.</p>            </article></div></div></main></div><footer class="bg-slate-100 border-t border-accent-2 mt-6"><div class="py-4 flex flex-col items-center justify-center text-xs text-slate-500"><a href="https://twitter.com/@JooStory">@JooStory</a></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"45","date":"2008. 3. 25. 15:39","title":"Unix Programming Environment 정리","content":"책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.\n\u003ch2\u003e1장 초보자를 위한 Unix\u003c/h2\u003e\n\u003ch3\u003e1.1 출발\u003c/h3\u003e\n\u003cp\u003e단말기와 타이핑\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003etty : teletype, terminal의 동의어\u003c/p\u003e\n\u003cp\u003e단말기의 이상동작\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003estty : set terminal options\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003estty -tabs\u003c/p\u003e\n\u003cp\u003e오타\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ereturn을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 이전 입력문자를 버린다. (현재는 ^U를 사용한다.)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e#를 누르면 이전 입력문자 1개를 버린다. (현재의 삭제와 같다.)\u003c/p\u003e\n\u003cp\u003e우편 사용하기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003email을 사용하면 현재 사용자에게 메일을 보낼 수 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ewrite를 사용하여 terminal상의 사용자에게 message를 보낼 수 있다.\u003c/p\u003e\n\u003ch3\u003e1.2 화일과 자주 쓰는 명령어\u003c/h3\u003e\n\u003cp\u003e편집기 ed\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ea : 입력시작 append\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e. : 입력 종료\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ew filename : 파일에 저장\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eq : 종료\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003en,mp : n-m줄까지 print 하라 $는 마지막 줄\u003c/p\u003e\n\u003cp\u003e화일의 프린트 - cat and pr\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ecat 은 화일을 화면에 출력한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003epr 은 프린트 가능한 형태로 보여준다.\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003epr -n : n개의 단으로 나누어 보여준다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003epr 과 lpr은 보통 같이 사용된다. nroff, troff 등의 프린트 명령이 있다.\u003c/p\u003e\n\u003cp\u003e유용한 명령들\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ewc : 단어 세기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003egrep : 찾기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003esort : 문자 정렬\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e-r : reverse\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e-n : 숫자 순으로 정렬 -nr 도 가능\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e-f : 대소문자 구분 x\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e+n : n+1번째부터\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003etail : 마지막 열을 기준으로 출력\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ecmp file1 file2 : 차이점 비교 (대부분 같은지를 확인할 때 사용)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ediff file1 file2 : 차이점 비교 (다름을 알고 어떻게 다른지 알고자 할 때 사용)\u003c/p\u003e\n\u003ch3\u003e1.3 디렉토리\u003c/h3\u003e\n\u003cp\u003e특별히 정리할 만한 내용이 없다.\u003c/p\u003e\n\u003ch3\u003e1.4 쉘\u003c/h3\u003e\n\u003cp\u003e쉘에서는 패턴을 사용할 수 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e패턴을 사용치 않으려면 ' 나 \\를 사용하면된다.\u003c/p\u003e\n\u003cp\u003e입출력 방향전환\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e\u0026gt; : 왼쪽의 출력을 오른쪽의 입력으로 전환한다. \u0026lt; 는 반대\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e\u0026gt;\u0026gt; : 동일하나 추가의 의미\u003c/p\u003e\n\u003cp\u003e파이프\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e\u0026gt; 가 표준입력을 전달했다면 | 는 인자를 전달한다.\u003c/p\u003e\n\u003cp\u003e프로세스\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e\u0026amp; : background 로 실행하라\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e파이프로 연결된 명령에 \u0026amp; 를 사용하면 모든 명령이 동시에 background로 전환되지만 마지막 PID만이 프린트된다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ewait : \u0026amp; 로 시작된 모든 프로세스를 기다린다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003enohup : \"no hangup\" 단말기가 로그아웃이 되더라도 명령을 계속 동작시킨다. 해당 명령의 출력은 nohup.out 에 저장된다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003enice : 프로세스의 순위를 변경한다. nohup은 실행되면 nice를 사용하여 실행하는 프로세스의 순위를 낮춘다. (로그아웃할 것이므로)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eat : 명령 수행 시간을 지정할 수 있다. (시간 형태 : 0000 or 0000(a|p)m\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e$ at 시간\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e명령어들...\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e^D\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003e$\u003c/p\u003e\n\u003cp\u003e환경꾸미기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e후진키 사용\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003estty erase '^h\"\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e프롬프트 사용 (PS1 변수를 변경하면 된다.)\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003ePS1='Prompt $'\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eexport 변수 : 쉘에게 변수 알리기\u003c/p\u003e\n\u003ch2\u003e2장 화일 시스템\u003c/h2\u003e\n\u003cp\u003eUnix 시스템에서는 모든 것이 화일이다.\u003c/p\u003e\n\u003ch3\u003e2.1 화일의 기본 사항\u003c/h3\u003e\n\u003cp\u003eod : (octal dump) 화일의 모든 바이트를 사용자가 볼 수 있도록 한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eod -c : 문자로 보이기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eod -b : 각 바이트를 8진수로 보여준다.\u003c/p\u003e\n\u003cp\u003e개행문자에 대한 터미널의 해석\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e\\n 은 od 같은 프로그램이 사용하는 관십의 표현이며 실제는 한 바이트인 8진수 012로 저장된다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e탭 같은 경우도 터미널이 문자를 보고 해석하여 화면에 뿌려주는데 커널이 하도록 할 수 있다. stty -tabs는 커널이 탭을 공백문자로 바꾼다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e개행문자로 마찬가지이다. 012를 캐리지 리턴과 개행으로 확장하여 출력한다. 일부 시스템(windows, joo생각)은 CRLF를 직접 파일에 입력한다. Unix에서는 사용자가 화일에 넣지 않은 어떠한 바이트도 사용하지 않는다.\u003c/p\u003e\n\u003ch3\u003e2.2 화일의 내용\u003c/h3\u003e\n\u003cp\u003eUnix 에서는 화일은 구별하려는 대신 화일의 차이점을 무시하려고 한다. 모든 화일은 문자와 개행문자로 구성된다. Unix에서는 화일에 접근하기 위해서는 단지 화일 이름만 알면 된다.\u003c/p\u003e\n\u003cp\u003e그러나 이것은 문제가 될 수 있다. 이진화일의 경우 개행문자 없이 수만문자가 이어져 나온다. 이 경우 Unix 프로그램은 제대로 수행되지 못한다. 한 줄에 대한 가상의 정의가 되어 있기 때문이다.\u003c/p\u003e\n\u003ch3\u003e2.3 디렉토리와 화일명\u003c/h3\u003e\n\u003cp\u003epwd : 현재의 디렉토리를 알려준다.\u003c/p\u003e\n\u003cp\u003edu : 한 디렉토리 내의 모든 화일과 모든 부디렉토리가 차지하는 디스크 공간의 양을 알려준다.\u003c/p\u003e\n\u003ch3\u003e2.4 접근권한\u003c/h3\u003e\n\u003cp\u003e화일에 접근권한을 두어서 다른 사용자가 자신의 화일을 볼 수 없도록 할 수 있다.\u003c/p\u003e\n\u003cp\u003esu를 사용해 수퍼유저이 될 수 있다. 이 경우 모든 화일에 접근할 수 있는데 수퍼유저도 볼 수 없는 화일을 만들기 위해 crypt를 사용할 수 있다.\u003c/p\u003e\n\u003cp\u003e/etc/passwd : 로그인정보를 포함해 암호정보를 가지고 있다.\u003c/p\u003e\n\u003cp\u003eset-uid : 화일권한에 x 대신 s가 있는 것은 화일이 실행되는 순간 그 화일의 소유자의 권한이 되는 것이다. 이것은 매우 유용하지만 잘못 사용하면 보안상의 문제가 생길 수 있다.\u003c/p\u003e\n\u003ch3\u003e2.5 i-노드\u003c/h3\u003e\n\u003cp\u003einode에는 세가지 시간이 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e최종수정시간 : 쓰여진 시간\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e최종사용시간 : 읽거나 수행된 시간\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e최종변경시간 : inode가 변경된 시간\u003c/p\u003e\n\u003cp\u003echmod, chown\u003c/p\u003e\n\u003ch3\u003e2.6 디렉토리 계층\u003c/h3\u003e\n\u003cp\u003e/bin : binaries\u003c/p\u003e\n\u003cp\u003e/dev : devices\u003c/p\u003e\n\u003cp\u003e/etc : et cetera\u003c/p\u003e\n\u003ch3\u003e2.7 장치\u003c/h3\u003e\n\u003cp\u003e/dev 에 있는 화일은 device로 사용되지만 Unix에는 동일하게 화일로 인식된다.\u003c/p\u003e\n\u003ch2\u003e3장 쉘의 사용\u003c/h2\u003e\n\u003ch3\u003e3.1 명령어 줄의 구조\u003c/h3\u003e\n\u003cp\u003e보통은 개행문자가 명령의 끝으로 인식되지만 ; 도 명령의 끝으로 인식된다.\u003c/p\u003e\n\u003cp\u003e; 로 구분된 명령을 파이프로 보낼때는 마지막 명령의 결과만이 파이프로 보내진다.\u003c/p\u003e\n\u003cp\u003e같이 보내기 위해서는 ()로 묶어주어야 한다.\u003c/p\u003e\n\u003cp\u003etee : 파이프로 흐르는 data를 화일로 저장하고 파이프로 그대로 흘려보낼 수 있다.\u003c/p\u003e\n\u003ch3\u003e3.2 메타문자\u003c/h3\u003e\n\u003cp\u003e* 과 같은 특수한 특성을 가진 문자\u003c/p\u003e\n\u003cp\u003e이들 메타문자가 해석되지 않도록 하기 위해서는 ' 로 감싸주면 된다.\u003c/p\u003e\n\u003cp\u003e줄 끝의 역슬래쉬는 그 줄이 다음줄에 계속 연결되는 것을 말한다.\u003c/p\u003e\n\u003cp\u003eecho는 명시적으로 요청받지 않아도 최종적으로 개행문자를 출력한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eecho -n , echo \"....\\c\" : 개행문자를 추가하지 않게 한다.\u003c/p\u003e\n\u003ch3\u003e3.3 새 명령어의 생성\u003c/h3\u003e\n\u003cp\u003eUnix의 여러가지 명령을 조합하여 새로운 명령을 만들 수 있다.\u003c/p\u003e\n\u003cp\u003e실행권한을 주게되면 쉘의 도움없이도 가능하다.\u003c/p\u003e\n\u003ch3\u003e3.4 명령어 인수 및 매개변수\u003c/h3\u003e\n\u003cp\u003e$1 ... $9 로 입력된 인자와 매개변수를 전달할 수 있다.\u003c/p\u003e\n\u003cp\u003e$* : 인자 모두를 뜻한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eecho 'grep $* /usr/you/lib/phone-book' \u0026gt; 114 로 114 명령을 만들 수 있는데..\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e114 'john mike' 에는 실제로 mike라는 화일에서 john을 찾는 것으로 해석될 수 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e따라서 $* 를 \"$*\" 과 같이 \" 로 감싸줄 필요가 있다.\u003c/p\u003e\n\u003cp\u003e$0 : 현재 수행되는 프로그램 이름이다.\u003c/p\u003e\n\u003ch3\u003e3.5 인수로서의 프로그램 출력\u003c/h3\u003e\n\u003cp\u003e` 로 감싼 부분은 수행된 뒤 그 결과를 반환한다.\u003c/p\u003e\n\u003cp\u003epick : 대화식 명령이 가능하다.\u003c/p\u003e\n\u003ch3\u003e3.6 쉘 변수\u003c/h3\u003e\n\u003cp\u003eset : 모든 정의된 변수의 값을 알 수 있다. (몇가지를 보기위해서는 echo를 쓰는 것이 더 좋다)\u003c/p\u003e\n\u003cp\u003eHOME, PATH 등이 쉘에서 사용된다.\u003c/p\u003e\n\u003cp\u003e어떤 변수의 값을 부속쉘에서도 접근가능하게 하려면 export를 쓰면 된다.\u003c/p\u003e\n\u003ch3\u003e3.7 I/O 방향전환에 대한 추가 사항\u003c/h3\u003e\n\u003cp\u003e\u0026gt; : 표준출력을 다른 곳으로 돌린다.\u003c/p\u003e\n\u003cp\u003e2\u0026gt; : 표준에러를 다른 곳으로 돌린다.\u003c/p\u003e\n\u003cp\u003e2\u0026gt;\u0026amp;1 : 표준에러를 표준출력과 같은 곳으로 한다.\u003c/p\u003e\n\u003cp\u003e\u0026lt;\u0026lt; s : (here docuement) s를 맨앞에 가진 줄 직전까지의 표준입력을 취한다.\u003c/p\u003e\n\u003ch3\u003e3.8 쉘 프로그램에서의 반복문 처리\u003c/h3\u003e\n\u003cp\u003efor 변수 in 단어들의 목록\u003c/p\u003e\n\u003cp\u003edo\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e명령어들\u003c/p\u003e\n\u003cp\u003edone\u003c/p\u003e\n\u003cp\u003efor 변수 in 목록 ; do 명령어들 ; done\u003c/p\u003e\n\u003cp\u003efor i in * 과 for i in $* 은 다르게 해석된다. 파일에서 $*로 사용하면 인자를 받아서 따로따로 수행하는 것이다.\u003c/p\u003e\n\u003ch3\u003e3.9 bundle : 모두 하나로 묶기\u003c/h3\u003e\n\u003cp\u003ebundle은 현재 사용되지 않는다.\u003c/p\u003e\n\u003ch3\u003e3.10 왜 하필이면 프로그램이 가능한 쉘인가?\u003c/h3\u003e\n\u003cp\u003e쉘은 프로그램으로 처리해야 하는 여러가지 문제를 해결해주기 때문에 이를 사용하는 것이 유익하다.\u003c/p\u003e\n\u003ch2\u003e4장 필터\u003c/h2\u003e\n\u003cp\u003esed : stream editor\u003c/p\u003e\n\u003cp\u003eawk : 제작자의 이름을 따서 만들었다.\u003c/p\u003e\n\u003ch3\u003e4.1 grep 류\u003c/h3\u003e\n\u003cp\u003e$ grep 패턴 화일명들 ...\u003c/p\u003e\n\u003cp\u003egrep, egrep, fgrep\u003c/p\u003e\n\u003ch3\u003e4.2 그 밖의 필터들\u003c/h3\u003e\n\u003cp\u003esort : 입력을 줄 단위로 아스키 순으로 정렬한다.\u003c/p\u003e\n\u003cp\u003euniq : 중복된 줄을 버린다. (-c 로 중복된 횟수를 셀 수 있다)\u003c/p\u003e\n\u003cp\u003ecomm : 화일을 비교한다.\u003c/p\u003e\n\u003cp\u003etr : 입력의 문자를 변경할 수 있다. (대소문자 변환에 흔히 쓰인다)\u003c/p\u003e\n\u003ch3\u003e4.3 스트림 편집기 sed\u003c/h3\u003e\n\u003cp\u003esed 는 ed를 고쳐서 사용되었다.\u003c/p\u003e\n\u003cp\u003e$ sed 'ed의 명령어' files...\u003c/p\u003e\n\u003cp\u003e명령\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e's/A/B/f' : substitute A to B, f=g 이면 모두 바꿈\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e'y/A/B/' : A스트링을 B스트링으로 바꾸라\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e-f file : 패턴을 파일로부터 읽어들인다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e-n : 자동 프린트를 하지 않는다. 명시적으로 p를 사용해야 프린트한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e'/pattern/d' : 매칭되는 줄을 삭제\u003c/p\u003e\n\u003ch3\u003e4.4 패턴의 조사 처리 언어 awk\u003c/h3\u003e\n\u003cp\u003e$ awk '프로그램' files ...\u003c/p\u003e\n\u003cp\u003e프로그램\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003epattern { action }\u003c/p\u003e\n\u003cp\u003eawk는 한번에 한 줄씩 화일명들에서 입력을 읽어들인다.\u003c/p\u003e\n\u003cp\u003e필드\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eawk는 각 입력 줄을 자동으로 필드로 나눈다. $1 .. $NF(마지막 필드)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e-F분리자 : 분리자를 지정한다. (FS=\"분리자\" 로도 쓸 수 있다)\u003c/p\u003e\n\u003cp\u003e프린트하기\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eNR : 현제 레코드번호 (= 줄번호)\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eprintf \"format\" : printf 를 사용해 출력할 수 있다.\u003c/p\u003e\n\u003cp\u003e패턴\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e== : 같다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e~ : 문자와 부합된다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e!~ : 문자와 부합되지 않는다.\u003c/p\u003e\n\u003cp\u003eBEGIN 및 END 패턴\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eBEGIN { ... } : 입력을 읽기 전에 수행된다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eEND { ... } : 입력을 읽은 후 수행된다.\u003c/p\u003e\n\u003cp\u003e산술과 변수 : awk의 진정한 강점은 입력 데이타에 대한 계산이 가능하다는데에 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eawk는 C와 동일한 산술연산을 사용할 수 있다.\u003c/p\u003e\n\u003cp\u003eawk의 내장 변수\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eFILENAME : 현재의 입력 화일명\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eFS : 필드 분리 문자\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eNF : 입력 레코드 내의 필드 수\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eNR : 입력 레코드 수\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eOFMT : 숫자의 출력 포맷\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eOFS : 출력 필드의 분리 문자열\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eORS : 출력 레코드의 분리 문자열\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eRS : 입력 레코드 분리 문자\u003c/p\u003e\n\u003cp\u003e제어흐름\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eC의 문법과 비슷하나 한 명령의 끝을 개행문자로 한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003enext : 다음 입력 줄을 불러들인다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eexit : END 패턴으로 즉각 넘어간다.\u003c/p\u003e\n\u003cp\u003e배열\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e선언하지않고 배열이 사용이 가능하다.\u003c/p\u003e\n\u003cp\u003eawk의 내장함수\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ecos(expr) : cosine\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eexp(expr) : 지수\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003egetline() : 다음 입력 줄을 읽고 화일의 끝이면 0, 아니면 1일 반환\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eindex(s1, s2) : s1에서 문자열 s2의 위치, 없으면 0\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eint(expr) : expr의 정수부, 버림법을 사용한다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003elength(s) : 문자열 s의 길이\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003elog(expr) : 자연로그\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003esin(expr) : sine\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003esplit(s, a, c) : s를 문자 c를 기준으로 a[1] ... a[n]으로 분리하고 n을 반환\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003esprintf(fmt, ...) : fmt에 따른 포맷\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003esubstr(s, m, n) : s내의 위치 m에서 시작하는 n 길이의 문자열\u003c/p\u003e\n\u003cp\u003e연관배열 : awk는 해쉬를 이용해 연관배열을 사용한다.\u003c/p\u003e\n\u003cp\u003e문자열\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003ea = a \" \" : awk에는 문자열 접합연산자가 특별히 없다. 단지 나열만으로 접합이 일어난다.\u003c/p\u003e\n\u003cp\u003e쉘과의 대화\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003eawk에서 인자를 받기위해서는 두가지 방식이 있다.\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003eawk '{ print $'$1' }'\u003c/p\u003e\n\u003cp style=\"margin-left: 4em;\"\u003eawk '{ print \\$$1 }'\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e따옴표를 사용하는 방법이 더 좋다. \\가 너무 많아지면 복잡해지기 때문이다.\u003c/p\u003e\n\u003cp style=\"margin-left: 2em;\"\u003e또한 BEGIN을 통해 자주 사용되는 부분을 변수화 해두면 복잡함을 줄일 수 있다.\u003c/p\u003e\n\u003ch3\u003e4.5 좋은 화일과 좋은 필터\u003c/h3\u003e\n\u003cp\u003eUnix에서 생성하는 출력은 다른 프로그램의 입력으로 쓰일 수 있다.\u003c/p\u003e            ","summary":"책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.\n1장 초보자를 위한 Unix\n1.1 출발\n단말기와 타이핑\n제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)\ntty : teletype, terminal의 동의어\n단말기의 이상동작\nstty : set terminal options\nstty -tabs\n오타\nreturn을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 ","image":"https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"}},"__N_SSG":true},"page":"/tistory/[id]","query":{"id":"45"},"buildId":"k2SjylS4DhAPzPoZgQ49x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>