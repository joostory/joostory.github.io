<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" href="/favicon.ico"/><meta name="description" content="JooStory.net"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><link rel="canonical" href="https://blog.joostory.net/464"/><title>Electron 시작하기 (2) - OAuth</title><meta property="og:type" content="article"/><meta property="og:title" content="Electron 시작하기 (2) - OAuth"/><meta property="og:description" content="Electron 시작하기 두번째에서 이야기할 것은 BrowserWindow를 사용한 OAuth 인증, main/renderer 프로세스 서로 간의 통신, 설정값 저장이다. 이 과정을 지나면 앱은 OAuth 인증이 된 상태로 유지될 것이다.
OAuth 2.0
먼저 이 예제는 다음블로그의 API를 사용할 것이기 때문에 OAuth 2.0으로 인증을 해야한다. dna 사이트에서 잘 설명하고 있지만 다시 OAuth 2.0과정을 살펴보자면 다음과 같다.

사용자가"/><meta property="og:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Electron 시작하기 (2) - OAuth"/><meta name="twitter:description" content="Electron 시작하기 두번째에서 이야기할 것은 BrowserWindow를 사용한 OAuth 인증, main/renderer 프로세스 서로 간의 통신, 설정값 저장이다. 이 과정을 지나면 앱은 OAuth 인증이 된 상태로 유지될 것이다.
OAuth 2.0
먼저 이 예제는 다음블로그의 API를 사용할 것이기 때문에 OAuth 2.0으로 인증을 해야한다. dna 사이트에서 잘 설명하고 있지만 다시 OAuth 2.0과정을 살펴보자면 다음과 같다.

사용자가"/><meta property="twitter:image" content="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/11ae7950df9656c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/11ae7950df9656c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f76bbe1730ea85a1.js" defer=""></script><script src="/_next/static/chunks/494-fa03e5491fc3b3a9.js" defer=""></script><script src="/_next/static/chunks/pages/tistory/%5Bid%5D-571a42114028488a.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_buildManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_ssgManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class=""><div class="pt-40 pb-36 px-20 border-b-[1px] relative"><h1 class="font-bold tracking-tighter leading-tight md:leading-none mb-4 text-center text-3xl">Electron 시작하기 (2) - OAuth</h1><div class="flex justify-center"><em class="text-sm"><time dateTime="2017. 2. 24. 15:03">2017. 2. 24. 15:03</time></em></div></div><div class="w-[650px] pt-10 pb-20 mx-auto"><article class="prose"><p>Electron 시작하기 두번째에서 이야기할 것은 <code>BrowserWindow</code>를 사용한 OAuth 인증, main/renderer 프로세스 서로 간의 통신, 설정값 저장이다. 이 과정을 지나면 앱은 OAuth 인증이 된 상태로 유지될 것이다.</p>
<h2 id="oauth-2-0">OAuth 2.0</h2>
<p>먼저 이 예제는 다음블로그의 API를 사용할 것이기 때문에 OAuth 2.0으로 인증을 해야한다. <a href="http://dna.daum.net/services/apis/docs/oauth2_0/reference">dna 사이트</a>에서 잘 설명하고 있지만 다시 OAuth 2.0과정을 살펴보자면 다음과 같다.</p>
<ol>
<li>사용자가 앱에서 인증을 시도한다.</li>
<li>앱은 발급받은 CLIENT ID를 비롯한 필요한 정보와 함께 <em>사용자 인증 URL</em>을 브라우저에서 연다.</li>
<li>사용자가 앱 사용 승인을 한다. 이때 <code>authorization_code</code>이 앱에 전달된다.</li>
<li>앱은 <code>authorization_code</code>로 <em>토큰 URL</em>을 호출하여 <code>access_token</code>을 얻는다.</li>
</ol>
<p>이 과정을 해야할 일로 바꿔보면 다음과 같을 것이다.</p>
<ol>
<li>사용자가 인증버튼을 클릭하면 renderer프로세스는 main프로세스에게 인증을 시작하라는 이벤트를 보낸다.</li>
<li>main프로세스는 새로운 <code>BrowserWindow</code>에 인증 URL을 로드한다.</li>
<li>생성된 브라우저에서 <code>redirect_url</code>로의 이동이 감지되면 <code>authorization_code</code>를 가져온다.</li>
<li>토큰 URL을 호출해서 <code>access_token</code>을 가져온다.</li>
</ol>
<p>이 일들을 해내려면 프로세스들간의 통신방법을 알아야 하고 BrowserWindow의 url변경을 감지할 수 있어야 한다. 먼저 프로세스들간의 통신방법을 알아본다.</p>
<h2 id="ipc">IPC</h2>
<p>Electron에서 main/renderer 프로세스는 IPC와 remote를 통해서 통신할 수 있다. 여기서 IPC에 대해서 알아볼 것이다. IPC 모듈은 ipcMain, ipcRenderer두가지가 있다. 각각 main, renderer 프로세스에서 사용한다.</p>
<pre><code>// renderer에서 main으로 이벤트를 호출한다.
ipcRenderer.send(&quot;request-auth&quot;)

// main에서 renderer가 보낸 이벤트를 수신한다.
ipcMain.on(&quot;request-auth&quot;, (e) =&gt; handleRequestAuth)
</code></pre><p>이벤트를 send하면 수신하는 함수는 첫번째 인자로 이벤트, 그 뒤는 send하면서 보낸 인자로 받는다. 그리고 <code>e.sender.send()</code>로 sender에게 이벤트를 send 할 수 있다. 이 부분까지만 이해하면 나머지는 쉽다. 이런 방식으로 모든 데이터를 주고 받으면서 앱을 만들면 된다.</p>
<h2 id="electron-oauth2">electron-oauth2</h2>
<p>IPC를 통해서 사용자의 액션을 수용할 수 있게 되었으니 이제 OAuth 2.0과정을 따라가본다. 따라가보려다 보니 이런 건 누군가 이미 만들어 뒀을 거라는 생각이 든다. 역시 <a href="https://www.npmjs.com/package/electron-oauth2">electron-oauth2</a>라는 잘 만들어진 라이브러리가 있다. 이 라이브러리는 <code>clint_id</code>, <code>client_secret</code>, <code>redirect_uri</code>만 알려주면 2,3,4 과정을 모두 해준다.</p>
<pre><code>const electronOAuth2 = require(&#39;electron-oauth2&#39;)

electronOAuth2(OAuth2_INFO, BrowserWindow_OPTIONS)
    .getAccessToken()
    .then(token =&gt; { ... })
</code></pre><p>이것으로 <code>access_token</code>까지 얻는 과정이 끝났다. 남은 것은 이 <code>access_token</code>을 저장하는 것이다.</p>
<h2 id="electron-json-storage">electron-json-storage</h2>
<p>Electron의 main 프로세스는 nodejs이기 때문에 자유롭게 nodejs로 할 수 있는 모든 방법을 사용해서 값을 저장할 수 있다. 그러나 플랫폼마다 다른 파일 시스템을 고려해서 값을 저장하기 위해서 이번에도 라이브러리를 사용하는 것이 좋겠다. <a href="https://www.npmjs.com/package/electron-json-storage">electron-json-storage</a>라는 라이브러리가 적절해보여 사용하기로 했다.</p>
<pre><code>storage.set(NAME, VALUE)
storage.get(NAME, (error, VALUE) =&gt; { ... })
</code></pre><hr>
<p>이제 인증, 이벤트 처리, 간단한 값 저장을 할 수 있게 되었으니 앱을 만들기 위한 가장 중요한 것은 다 할 수 있게 되었다. 다음 글은 Electron이라는 주제에서는 약간 벗어나는 듯 하지만 어쨌든 몹시 중요한 UI를 만드는 것에 대한 글이 될 것 같다. React에 대한 글이란 말이다.</p>
            </article></div></div></main></div><footer class="bg-slate-100 border-t border-accent-2 mt-6"><div class="py-4 flex flex-col items-center justify-center text-xs text-slate-500"><a href="https://twitter.com/@JooStory">@JooStory</a></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"464","date":"2017. 2. 24. 15:03","title":"Electron 시작하기 (2) - OAuth","content":"\u003cp\u003eElectron 시작하기 두번째에서 이야기할 것은 \u003ccode\u003eBrowserWindow\u003c/code\u003e를 사용한 OAuth 인증, main/renderer 프로세스 서로 간의 통신, 설정값 저장이다. 이 과정을 지나면 앱은 OAuth 인증이 된 상태로 유지될 것이다.\u003c/p\u003e\n\u003ch2 id=\"oauth-2-0\"\u003eOAuth 2.0\u003c/h2\u003e\n\u003cp\u003e먼저 이 예제는 다음블로그의 API를 사용할 것이기 때문에 OAuth 2.0으로 인증을 해야한다. \u003ca href=\"http://dna.daum.net/services/apis/docs/oauth2_0/reference\"\u003edna 사이트\u003c/a\u003e에서 잘 설명하고 있지만 다시 OAuth 2.0과정을 살펴보자면 다음과 같다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e사용자가 앱에서 인증을 시도한다.\u003c/li\u003e\n\u003cli\u003e앱은 발급받은 CLIENT ID를 비롯한 필요한 정보와 함께 \u003cem\u003e사용자 인증 URL\u003c/em\u003e을 브라우저에서 연다.\u003c/li\u003e\n\u003cli\u003e사용자가 앱 사용 승인을 한다. 이때 \u003ccode\u003eauthorization_code\u003c/code\u003e이 앱에 전달된다.\u003c/li\u003e\n\u003cli\u003e앱은 \u003ccode\u003eauthorization_code\u003c/code\u003e로 \u003cem\u003e토큰 URL\u003c/em\u003e을 호출하여 \u003ccode\u003eaccess_token\u003c/code\u003e을 얻는다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 과정을 해야할 일로 바꿔보면 다음과 같을 것이다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e사용자가 인증버튼을 클릭하면 renderer프로세스는 main프로세스에게 인증을 시작하라는 이벤트를 보낸다.\u003c/li\u003e\n\u003cli\u003emain프로세스는 새로운 \u003ccode\u003eBrowserWindow\u003c/code\u003e에 인증 URL을 로드한다.\u003c/li\u003e\n\u003cli\u003e생성된 브라우저에서 \u003ccode\u003eredirect_url\u003c/code\u003e로의 이동이 감지되면 \u003ccode\u003eauthorization_code\u003c/code\u003e를 가져온다.\u003c/li\u003e\n\u003cli\u003e토큰 URL을 호출해서 \u003ccode\u003eaccess_token\u003c/code\u003e을 가져온다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 일들을 해내려면 프로세스들간의 통신방법을 알아야 하고 BrowserWindow의 url변경을 감지할 수 있어야 한다. 먼저 프로세스들간의 통신방법을 알아본다.\u003c/p\u003e\n\u003ch2 id=\"ipc\"\u003eIPC\u003c/h2\u003e\n\u003cp\u003eElectron에서 main/renderer 프로세스는 IPC와 remote를 통해서 통신할 수 있다. 여기서 IPC에 대해서 알아볼 것이다. IPC 모듈은 ipcMain, ipcRenderer두가지가 있다. 각각 main, renderer 프로세스에서 사용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// renderer에서 main으로 이벤트를 호출한다.\nipcRenderer.send(\u0026quot;request-auth\u0026quot;)\n\n// main에서 renderer가 보낸 이벤트를 수신한다.\nipcMain.on(\u0026quot;request-auth\u0026quot;, (e) =\u0026gt; handleRequestAuth)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e이벤트를 send하면 수신하는 함수는 첫번째 인자로 이벤트, 그 뒤는 send하면서 보낸 인자로 받는다. 그리고 \u003ccode\u003ee.sender.send()\u003c/code\u003e로 sender에게 이벤트를 send 할 수 있다. 이 부분까지만 이해하면 나머지는 쉽다. 이런 방식으로 모든 데이터를 주고 받으면서 앱을 만들면 된다.\u003c/p\u003e\n\u003ch2 id=\"electron-oauth2\"\u003eelectron-oauth2\u003c/h2\u003e\n\u003cp\u003eIPC를 통해서 사용자의 액션을 수용할 수 있게 되었으니 이제 OAuth 2.0과정을 따라가본다. 따라가보려다 보니 이런 건 누군가 이미 만들어 뒀을 거라는 생각이 든다. 역시 \u003ca href=\"https://www.npmjs.com/package/electron-oauth2\"\u003eelectron-oauth2\u003c/a\u003e라는 잘 만들어진 라이브러리가 있다. 이 라이브러리는 \u003ccode\u003eclint_id\u003c/code\u003e, \u003ccode\u003eclient_secret\u003c/code\u003e, \u003ccode\u003eredirect_uri\u003c/code\u003e만 알려주면 2,3,4 과정을 모두 해준다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst electronOAuth2 = require(\u0026#39;electron-oauth2\u0026#39;)\n\nelectronOAuth2(OAuth2_INFO, BrowserWindow_OPTIONS)\n    .getAccessToken()\n    .then(token =\u0026gt; { ... })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e이것으로 \u003ccode\u003eaccess_token\u003c/code\u003e까지 얻는 과정이 끝났다. 남은 것은 이 \u003ccode\u003eaccess_token\u003c/code\u003e을 저장하는 것이다.\u003c/p\u003e\n\u003ch2 id=\"electron-json-storage\"\u003eelectron-json-storage\u003c/h2\u003e\n\u003cp\u003eElectron의 main 프로세스는 nodejs이기 때문에 자유롭게 nodejs로 할 수 있는 모든 방법을 사용해서 값을 저장할 수 있다. 그러나 플랫폼마다 다른 파일 시스템을 고려해서 값을 저장하기 위해서 이번에도 라이브러리를 사용하는 것이 좋겠다. \u003ca href=\"https://www.npmjs.com/package/electron-json-storage\"\u003eelectron-json-storage\u003c/a\u003e라는 라이브러리가 적절해보여 사용하기로 했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estorage.set(NAME, VALUE)\nstorage.get(NAME, (error, VALUE) =\u0026gt; { ... })\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003cp\u003e이제 인증, 이벤트 처리, 간단한 값 저장을 할 수 있게 되었으니 앱을 만들기 위한 가장 중요한 것은 다 할 수 있게 되었다. 다음 글은 Electron이라는 주제에서는 약간 벗어나는 듯 하지만 어쨌든 몹시 중요한 UI를 만드는 것에 대한 글이 될 것 같다. React에 대한 글이란 말이다.\u003c/p\u003e\n            ","summary":"Electron 시작하기 두번째에서 이야기할 것은 BrowserWindow를 사용한 OAuth 인증, main/renderer 프로세스 서로 간의 통신, 설정값 저장이다. 이 과정을 지나면 앱은 OAuth 인증이 된 상태로 유지될 것이다.\nOAuth 2.0\n먼저 이 예제는 다음블로그의 API를 사용할 것이기 때문에 OAuth 2.0으로 인증을 해야한다. dna 사이트에서 잘 설명하고 있지만 다시 OAuth 2.0과정을 살펴보자면 다음과 같다.\n\n사용자가","image":"https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"}},"__N_SSG":true},"page":"/tistory/[id]","query":{"id":"464"},"buildId":"k2SjylS4DhAPzPoZgQ49x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>