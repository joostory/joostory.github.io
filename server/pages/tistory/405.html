<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" href="/favicon.ico"/><meta name="description" content="JooStory.net"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><link rel="canonical" href="https://blog.joostory.net/405"/><title>Markdown Editor를 React로 재작성</title><meta property="og:type" content="article"/><meta property="og:title" content="Markdown Editor를 React로 재작성"/><meta property="og:description" content="codemirror에 한참 빠져있을때 간단히 만든 markdown to html 에디터가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.
그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던"/><meta property="og:image" content="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F23695C3856AB4B1434"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Markdown Editor를 React로 재작성"/><meta name="twitter:description" content="codemirror에 한참 빠져있을때 간단히 만든 markdown to html 에디터가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.
그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던"/><meta property="twitter:image" content="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F23695C3856AB4B1434"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/11ae7950df9656c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/11ae7950df9656c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f76bbe1730ea85a1.js" defer=""></script><script src="/_next/static/chunks/494-fa03e5491fc3b3a9.js" defer=""></script><script src="/_next/static/chunks/pages/tistory/%5Bid%5D-571a42114028488a.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_buildManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_ssgManifest.js" defer=""></script><script src="/_next/static/k2SjylS4DhAPzPoZgQ49x/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class=""><div class="pt-40 pb-36 px-20 border-b-[1px] relative"><h1 class="font-bold tracking-tighter leading-tight md:leading-none mb-4 text-center text-3xl">Markdown Editor를 React로 재작성</h1><div class="flex justify-center"><em class="text-sm"><time dateTime="2016. 1. 29. 20:22">2016. 1. 29. 20:22</time></em></div></div><div class="w-[650px] pt-10 pb-20 mx-auto"><article class="prose"><p><a href="http://codemirror.net">codemirror</a>에 한참 빠져있을때 간단히 만든 <a href="http://dev.joostory.net/markdown">markdown to html 에디터</a>가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.</p>
<p>그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던 CommonJS도 알게 되었다. <a href="http://blog.joostory.net/404">react에 webpack을 적용</a>하면서는 눈이 번쩍 뜨이는 것 같았다. 이런 방법이 있는데 왜 그동안 그렇게 고생했던 것일까 싶다. (사실 CommonJS만 알았어도 더 속도가 붙었을 것 같다.)</p>
<p>지금부터 이전에 만들었던 markdown 에디터를 react와 재작성한 과정을 정리해보려고 한다. 정리를 한번 하면 좀 더 이해한 것이 머리 속에 더 깊이 들어오리라 기대하면서...</p>
<h2 id="header--">구조</h2>
<figure><span class="imageblock" style="display:inline-block;width:820px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434?download" data-lightbox="lightbox"><img srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F23695C3856AB4B14343AA8" src="https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434" style="cursor: pointer;max-width:100%;height:auto" width="820" height="520" filename="스크린샷 2016-01-29 오후 7.32.21.png" filemime="image/png" ></span></span></figure>
<p>구조는 간단하다. 왼쪽에 <em>에디터</em>, 오른쪽에 <em>미리보기</em>가 있고 크기를 조정할 수 있는 <em>칸막이</em>가 있다. <em>에디터</em>에 markdown으로 내용을 입력하면 <em>미리보기</em>에 이를 html로 변환해서 보여준다. <em>Preview탭</em>에는 html을 렌더링해서 보여주고 <em>HTML탭</em>에는 html 코드로 보여준다.</p>
<pre><code>var Editor = require('./editor');
var Divider = require('./divider');
var Preview = require('./preview');

var App = React.createClass({

    ...

    render: function() {
        return (
            &lt;div className="editor-container"&gt;
                &lt;Editor onChange={this.handleChangeEditorValue} /&gt;
                &lt;Divider /&gt;
                &lt;Preview value={this.state.value} /&gt;
            &lt;/div&gt;
        );
    }
});


ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById("container")
);
</code></pre><p>react의 좋은 점 중 하나는 이런 식으로 생각한 것을 그대로 코드로 옮기면 된다는 점이다. 이제 <code>Editor</code>와 <code>Divider</code>, <code>Preview</code>를 각각 구현해주면 된다. 각 모듈은 CommonJS 방식으로 로드하기 때문에 webpack 설정에 필요한 파일들을 넣는다.</p>
<pre><code>module.exports = {
    entry: {
        'editor': [
            path.join(__dirname, 'static/js/editor/app'),
            path.join(__dirname, 'static/js/editor/editor'),
            path.join(__dirname, 'static/js/editor/codemirror-editor'),
            path.join(__dirname, 'static/js/editor/preview'),
        ]
    },
}
</code></pre><p>webpack에 <code>--watch</code> 옵션을 넣어 실행하면 파일을 수정할때마다 매번 webpack을 실행하는 수고를 하지 않아도 된다.</p>
<h2 id="header-editor">Editor</h2>
<pre><code>var CodeMirrorEditor = require('./codemirror-editor');

var Editor = React.createClass({
    render: function() {
        return (
            &lt;div className="editor"&gt;
                &lt;EditorHeader /&gt;
                &lt;CodeMirrorEditor placeholder="내용을 입력하세요" onChange={this.props.onChange} /&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre><p>에디터는 Header때문에 한번 더 감싼 것이고 실제로는 CodeMirrorEditor를 사용하도록 했다.</p>
<pre><code>var CodeMirror = require('codemirror');

var CodeMirrorEditor = React.createClass({
    componentDidMount: function() {
        this.codeMirror = CodeMirror.fromTextArea(this.refs.textarea, this.props.options);
        this.codeMirror.on('change', this.handleChange);
    },
    componentWillUnmount: function() {
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
        }
    },
    handleChange: function(doc) {
        this.setState({
            value: doc.getValue()
        });
        this.props.onChange(this.state.value);
    },
    render: function() {
        return (
            &lt;div className="editor-content"&gt;
                &lt;textarea ref="textarea" placeholder={this.props.placeholder}&gt;{this.props.value}&lt;/textarea&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre><p>CodeMirror는 React Class가 아니기 때문에 <code>componentDidMount</code>와 <code>ref</code>를 사용해서 초기화했다. <a href="https://github.com/JedWatson/react-codemirror">react-codemirror</a>가 있기는 한데 placeholder plugin을 지원하지 않아서 사용하지 않았다. codemirror를 잘 모르는 상태라면 react-codemirror를 사용하는 것도 나쁘지 않을 것 같다.</p>
<h2 id="header-preview">Preview</h2>
<pre><code>var marked = require('marked');
marked.setOptions({
    headerPrefix: "header-"
});

var Preview = React.createClass({
    render: function() {
        var style = {
            left: this.props.position
        };
        var value = marked(this.props.value);
        var html = {
            __html: value
        }

        return (
            &lt;div className="preview" style={style}&gt;
                &lt;ul id="resultTab" className="nav nav-tabs" role="tablist"&gt;
                    &lt;li role="presentation" className="active"&gt;&lt;a href="#preview" aria-controls="preview" role="tab" data-toggle="tab"&gt;Preview&lt;/a&gt;&lt;/li&gt;
                    &lt;li role="presentation"&gt;&lt;a href="#html" aria-controls="html" role="tab" data-toggle="tab"&gt;HTML&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;div className="tab-content"&gt;
                    &lt;div ref="preview" id="preview" role="tabpanel" className="tab-pane result_preview active" dangerouslySetInnerHTML={html}&gt;&lt;/div&gt;
                    &lt;textarea ref="rawPreview" id="html" role="tabpanel" className="tab-pane result_html" readonly="readonly" value={value}&gt;&lt;/textarea&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre><p>미리보기에는 markdown to html을 해주는 라이브러리를 사용했는데 <a href="https://github.com/chjj/marked">marked</a>를 사용했다. react-marked라는 것도 있던데 그건 결과가 react class라서 marked를 사용했다. html을 render해야해서 어쩔 수 없이 <code>dangerouslySetInnerHTML</code>를 사용했다.</p>
<h2 id="header--">마치며</h2>
<p>react는 UI를 구조화할 수 있게 해주고 CommonJS는 소스코드를 구조화할 수 있게 해준다. 이 둘이 있어서 너무 좋다. 그동안 왜 이걸 안썼는지, 아니 왜 몰랐는지... 바보가 되는 것은 참 쉽다는 생각이 들었다. 가만히 있으면 바보가 된다. 늘 공부하며 살아야겠다.</p>
<p>지금까지 정리한 것은 <a href="http://dev.joostory.net/markdown" target="_blank" class="tx-link">이전에 만들었던 것</a>을 <a href="http://dev.joostory.net/editor" target="_blank" class="tx-link">재작성한 것</a>이고 이제는 추가하려고 했던 기능을 넣어보려고 한다. 오랜만에 두근두근 한다.</p>            </article></div></div></main></div><footer class="bg-slate-100 border-t border-accent-2 mt-6"><div class="py-4 flex flex-col items-center justify-center text-xs text-slate-500"><a href="https://twitter.com/@JooStory">@JooStory</a></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"405","date":"2016. 1. 29. 20:22","title":"Markdown Editor를 React로 재작성","content":"\u003cp\u003e\u003ca href=\"http://codemirror.net\"\u003ecodemirror\u003c/a\u003e에 한참 빠져있을때 간단히 만든 \u003ca href=\"http://dev.joostory.net/markdown\"\u003emarkdown to html 에디터\u003c/a\u003e가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.\u003c/p\u003e\n\u003cp\u003e그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던 CommonJS도 알게 되었다. \u003ca href=\"http://blog.joostory.net/404\"\u003ereact에 webpack을 적용\u003c/a\u003e하면서는 눈이 번쩍 뜨이는 것 같았다. 이런 방법이 있는데 왜 그동안 그렇게 고생했던 것일까 싶다. (사실 CommonJS만 알았어도 더 속도가 붙었을 것 같다.)\u003c/p\u003e\n\u003cp\u003e지금부터 이전에 만들었던 markdown 에디터를 react와 재작성한 과정을 정리해보려고 한다. 정리를 한번 하면 좀 더 이해한 것이 머리 속에 더 깊이 들어오리라 기대하면서...\u003c/p\u003e\n\u003ch2 id=\"header--\"\u003e구조\u003c/h2\u003e\n\u003cfigure\u003e\u003cspan class=\"imageblock\" style=\"display:inline-block;width:820px;;height:auto;max-width:100%\"\u003e\u003cspan data-url=\"https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434?download\" data-lightbox=\"lightbox\"\u003e\u003cimg srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F23695C3856AB4B14343AA8\" src=\"https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434\" style=\"cursor: pointer;max-width:100%;height:auto\" width=\"820\" height=\"520\" filename=\"스크린샷 2016-01-29 오후 7.32.21.png\" filemime=\"image/png\" \u003e\u003c/span\u003e\u003c/span\u003e\u003c/figure\u003e\n\u003cp\u003e구조는 간단하다. 왼쪽에 \u003cem\u003e에디터\u003c/em\u003e, 오른쪽에 \u003cem\u003e미리보기\u003c/em\u003e가 있고 크기를 조정할 수 있는 \u003cem\u003e칸막이\u003c/em\u003e가 있다. \u003cem\u003e에디터\u003c/em\u003e에 markdown으로 내용을 입력하면 \u003cem\u003e미리보기\u003c/em\u003e에 이를 html로 변환해서 보여준다. \u003cem\u003ePreview탭\u003c/em\u003e에는 html을 렌더링해서 보여주고 \u003cem\u003eHTML탭\u003c/em\u003e에는 html 코드로 보여준다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar Editor = require('./editor');\nvar Divider = require('./divider');\nvar Preview = require('./preview');\n\nvar App = React.createClass({\n\n    ...\n\n    render: function() {\n        return (\n            \u0026lt;div className=\"editor-container\"\u0026gt;\n                \u0026lt;Editor onChange={this.handleChangeEditorValue} /\u0026gt;\n                \u0026lt;Divider /\u0026gt;\n                \u0026lt;Preview value={this.state.value} /\u0026gt;\n            \u0026lt;/div\u0026gt;\n        );\n    }\n});\n\n\nReactDOM.render(\n    \u0026lt;App /\u0026gt;,\n    document.getElementById(\"container\")\n);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ereact의 좋은 점 중 하나는 이런 식으로 생각한 것을 그대로 코드로 옮기면 된다는 점이다. 이제 \u003ccode\u003eEditor\u003c/code\u003e와 \u003ccode\u003eDivider\u003c/code\u003e, \u003ccode\u003ePreview\u003c/code\u003e를 각각 구현해주면 된다. 각 모듈은 CommonJS 방식으로 로드하기 때문에 webpack 설정에 필요한 파일들을 넣는다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodule.exports = {\n    entry: {\n        'editor': [\n            path.join(__dirname, 'static/js/editor/app'),\n            path.join(__dirname, 'static/js/editor/editor'),\n            path.join(__dirname, 'static/js/editor/codemirror-editor'),\n            path.join(__dirname, 'static/js/editor/preview'),\n        ]\n    },\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewebpack에 \u003ccode\u003e--watch\u003c/code\u003e 옵션을 넣어 실행하면 파일을 수정할때마다 매번 webpack을 실행하는 수고를 하지 않아도 된다.\u003c/p\u003e\n\u003ch2 id=\"header-editor\"\u003eEditor\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar CodeMirrorEditor = require('./codemirror-editor');\n\nvar Editor = React.createClass({\n    render: function() {\n        return (\n            \u0026lt;div className=\"editor\"\u0026gt;\n                \u0026lt;EditorHeader /\u0026gt;\n                \u0026lt;CodeMirrorEditor placeholder=\"내용을 입력하세요\" onChange={this.props.onChange} /\u0026gt;\n            \u0026lt;/div\u0026gt;\n        );\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e에디터는 Header때문에 한번 더 감싼 것이고 실제로는 CodeMirrorEditor를 사용하도록 했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar CodeMirror = require('codemirror');\n\nvar CodeMirrorEditor = React.createClass({\n    componentDidMount: function() {\n        this.codeMirror = CodeMirror.fromTextArea(this.refs.textarea, this.props.options);\n        this.codeMirror.on('change', this.handleChange);\n    },\n    componentWillUnmount: function() {\n        if (this.codeMirror) {\n            this.codeMirror.toTextArea();\n        }\n    },\n    handleChange: function(doc) {\n        this.setState({\n            value: doc.getValue()\n        });\n        this.props.onChange(this.state.value);\n    },\n    render: function() {\n        return (\n            \u0026lt;div className=\"editor-content\"\u0026gt;\n                \u0026lt;textarea ref=\"textarea\" placeholder={this.props.placeholder}\u0026gt;{this.props.value}\u0026lt;/textarea\u0026gt;\n            \u0026lt;/div\u0026gt;\n        );\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCodeMirror는 React Class가 아니기 때문에 \u003ccode\u003ecomponentDidMount\u003c/code\u003e와 \u003ccode\u003eref\u003c/code\u003e를 사용해서 초기화했다. \u003ca href=\"https://github.com/JedWatson/react-codemirror\"\u003ereact-codemirror\u003c/a\u003e가 있기는 한데 placeholder plugin을 지원하지 않아서 사용하지 않았다. codemirror를 잘 모르는 상태라면 react-codemirror를 사용하는 것도 나쁘지 않을 것 같다.\u003c/p\u003e\n\u003ch2 id=\"header-preview\"\u003ePreview\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar marked = require('marked');\nmarked.setOptions({\n    headerPrefix: \"header-\"\n});\n\nvar Preview = React.createClass({\n    render: function() {\n        var style = {\n            left: this.props.position\n        };\n        var value = marked(this.props.value);\n        var html = {\n            __html: value\n        }\n\n        return (\n            \u0026lt;div className=\"preview\" style={style}\u0026gt;\n                \u0026lt;ul id=\"resultTab\" className=\"nav nav-tabs\" role=\"tablist\"\u0026gt;\n                    \u0026lt;li role=\"presentation\" className=\"active\"\u0026gt;\u0026lt;a href=\"#preview\" aria-controls=\"preview\" role=\"tab\" data-toggle=\"tab\"\u0026gt;Preview\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n                    \u0026lt;li role=\"presentation\"\u0026gt;\u0026lt;a href=\"#html\" aria-controls=\"html\" role=\"tab\" data-toggle=\"tab\"\u0026gt;HTML\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n                \u0026lt;/ul\u0026gt;\n\n                \u0026lt;div className=\"tab-content\"\u0026gt;\n                    \u0026lt;div ref=\"preview\" id=\"preview\" role=\"tabpanel\" className=\"tab-pane result_preview active\" dangerouslySetInnerHTML={html}\u0026gt;\u0026lt;/div\u0026gt;\n                    \u0026lt;textarea ref=\"rawPreview\" id=\"html\" role=\"tabpanel\" className=\"tab-pane result_html\" readonly=\"readonly\" value={value}\u0026gt;\u0026lt;/textarea\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        );\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e미리보기에는 markdown to html을 해주는 라이브러리를 사용했는데 \u003ca href=\"https://github.com/chjj/marked\"\u003emarked\u003c/a\u003e를 사용했다. react-marked라는 것도 있던데 그건 결과가 react class라서 marked를 사용했다. html을 render해야해서 어쩔 수 없이 \u003ccode\u003edangerouslySetInnerHTML\u003c/code\u003e를 사용했다.\u003c/p\u003e\n\u003ch2 id=\"header--\"\u003e마치며\u003c/h2\u003e\n\u003cp\u003ereact는 UI를 구조화할 수 있게 해주고 CommonJS는 소스코드를 구조화할 수 있게 해준다. 이 둘이 있어서 너무 좋다. 그동안 왜 이걸 안썼는지, 아니 왜 몰랐는지... 바보가 되는 것은 참 쉽다는 생각이 들었다. 가만히 있으면 바보가 된다. 늘 공부하며 살아야겠다.\u003c/p\u003e\n\u003cp\u003e지금까지 정리한 것은 \u003ca href=\"http://dev.joostory.net/markdown\" target=\"_blank\" class=\"tx-link\"\u003e이전에 만들었던 것\u003c/a\u003e을 \u003ca href=\"http://dev.joostory.net/editor\" target=\"_blank\" class=\"tx-link\"\u003e재작성한 것\u003c/a\u003e이고 이제는 추가하려고 했던 기능을 넣어보려고 한다. 오랜만에 두근두근 한다.\u003c/p\u003e            ","summary":"codemirror에 한참 빠져있을때 간단히 만든 markdown to html 에디터가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.\n그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던","image":"https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2\u0026fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F23695C3856AB4B1434"}},"__N_SSG":true},"page":"/tistory/[id]","query":{"id":"405"},"buildId":"k2SjylS4DhAPzPoZgQ49x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>