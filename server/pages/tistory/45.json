{"pageProps":{"post":{"id":"45","date":"2008. 3. 25. 15:39","title":"Unix Programming Environment 정리","content":"책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.\n<h2>1장 초보자를 위한 Unix</h2>\n<h3>1.1 출발</h3>\n<p>단말기와 타이핑</p>\n<p style=\"margin-left: 2em;\">제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)</p>\n<p style=\"margin-left: 2em;\">tty : teletype, terminal의 동의어</p>\n<p>단말기의 이상동작</p>\n<p style=\"margin-left: 2em;\">stty : set terminal options</p>\n<p style=\"margin-left: 2em;\">stty -tabs</p>\n<p>오타</p>\n<p style=\"margin-left: 2em;\">return을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 이전 입력문자를 버린다. (현재는 ^U를 사용한다.)</p>\n<p style=\"margin-left: 2em;\">#를 누르면 이전 입력문자 1개를 버린다. (현재의 삭제와 같다.)</p>\n<p>우편 사용하기</p>\n<p style=\"margin-left: 2em;\">mail을 사용하면 현재 사용자에게 메일을 보낼 수 있다.</p>\n<p style=\"margin-left: 2em;\">write를 사용하여 terminal상의 사용자에게 message를 보낼 수 있다.</p>\n<h3>1.2 화일과 자주 쓰는 명령어</h3>\n<p>편집기 ed</p>\n<p style=\"margin-left: 2em;\">a : 입력시작 append</p>\n<p style=\"margin-left: 2em;\">. : 입력 종료</p>\n<p style=\"margin-left: 2em;\">w filename : 파일에 저장</p>\n<p style=\"margin-left: 2em;\">q : 종료</p>\n<p style=\"margin-left: 2em;\">n,mp : n-m줄까지 print 하라 $는 마지막 줄</p>\n<p>화일의 프린트 - cat and pr</p>\n<p style=\"margin-left: 2em;\">cat 은 화일을 화면에 출력한다.</p>\n<p style=\"margin-left: 2em;\">pr 은 프린트 가능한 형태로 보여준다.</p>\n<p style=\"margin-left: 4em;\">pr -n : n개의 단으로 나누어 보여준다.</p>\n<p style=\"margin-left: 2em;\">pr 과 lpr은 보통 같이 사용된다. nroff, troff 등의 프린트 명령이 있다.</p>\n<p>유용한 명령들</p>\n<p style=\"margin-left: 2em;\">wc : 단어 세기</p>\n<p style=\"margin-left: 2em;\">grep : 찾기</p>\n<p style=\"margin-left: 2em;\">sort : 문자 정렬</p>\n<p style=\"margin-left: 4em;\">-r : reverse</p>\n<p style=\"margin-left: 4em;\">-n : 숫자 순으로 정렬 -nr 도 가능</p>\n<p style=\"margin-left: 4em;\">-f : 대소문자 구분 x</p>\n<p style=\"margin-left: 4em;\">+n : n+1번째부터</p>\n<p style=\"margin-left: 2em;\">tail : 마지막 열을 기준으로 출력</p>\n<p style=\"margin-left: 2em;\">cmp file1 file2 : 차이점 비교 (대부분 같은지를 확인할 때 사용)</p>\n<p style=\"margin-left: 2em;\">diff file1 file2 : 차이점 비교 (다름을 알고 어떻게 다른지 알고자 할 때 사용)</p>\n<h3>1.3 디렉토리</h3>\n<p>특별히 정리할 만한 내용이 없다.</p>\n<h3>1.4 쉘</h3>\n<p>쉘에서는 패턴을 사용할 수 있다.</p>\n<p style=\"margin-left: 2em;\">패턴을 사용치 않으려면 ' 나 \\를 사용하면된다.</p>\n<p>입출력 방향전환</p>\n<p style=\"margin-left: 2em;\">&gt; : 왼쪽의 출력을 오른쪽의 입력으로 전환한다. &lt; 는 반대</p>\n<p style=\"margin-left: 2em;\">&gt;&gt; : 동일하나 추가의 의미</p>\n<p>파이프</p>\n<p style=\"margin-left: 2em;\">&gt; 가 표준입력을 전달했다면 | 는 인자를 전달한다.</p>\n<p>프로세스</p>\n<p style=\"margin-left: 2em;\">&amp; : background 로 실행하라</p>\n<p style=\"margin-left: 2em;\">파이프로 연결된 명령에 &amp; 를 사용하면 모든 명령이 동시에 background로 전환되지만 마지막 PID만이 프린트된다.</p>\n<p style=\"margin-left: 2em;\">wait : &amp; 로 시작된 모든 프로세스를 기다린다.</p>\n<p style=\"margin-left: 2em;\">nohup : \"no hangup\" 단말기가 로그아웃이 되더라도 명령을 계속 동작시킨다. 해당 명령의 출력은 nohup.out 에 저장된다.</p>\n<p style=\"margin-left: 2em;\">nice : 프로세스의 순위를 변경한다. nohup은 실행되면 nice를 사용하여 실행하는 프로세스의 순위를 낮춘다. (로그아웃할 것이므로)</p>\n<p style=\"margin-left: 2em;\">at : 명령 수행 시간을 지정할 수 있다. (시간 형태 : 0000 or 0000(a|p)m</p>\n<p style=\"margin-left: 4em;\">$ at 시간</p>\n<p style=\"margin-left: 4em;\">명령어들...</p>\n<p style=\"margin-left: 4em;\">^D</p>\n<p style=\"margin-left: 4em;\">$</p>\n<p>환경꾸미기</p>\n<p style=\"margin-left: 2em;\">후진키 사용</p>\n<p style=\"margin-left: 4em;\">stty erase '^h\"</p>\n<p style=\"margin-left: 2em;\">프롬프트 사용 (PS1 변수를 변경하면 된다.)</p>\n<p style=\"margin-left: 4em;\">PS1='Prompt $'</p>\n<p style=\"margin-left: 2em;\">export 변수 : 쉘에게 변수 알리기</p>\n<h2>2장 화일 시스템</h2>\n<p>Unix 시스템에서는 모든 것이 화일이다.</p>\n<h3>2.1 화일의 기본 사항</h3>\n<p>od : (octal dump) 화일의 모든 바이트를 사용자가 볼 수 있도록 한다.</p>\n<p style=\"margin-left: 2em;\">od -c : 문자로 보이기</p>\n<p style=\"margin-left: 2em;\">od -b : 각 바이트를 8진수로 보여준다.</p>\n<p>개행문자에 대한 터미널의 해석</p>\n<p style=\"margin-left: 2em;\">\\n 은 od 같은 프로그램이 사용하는 관십의 표현이며 실제는 한 바이트인 8진수 012로 저장된다.</p>\n<p style=\"margin-left: 2em;\">탭 같은 경우도 터미널이 문자를 보고 해석하여 화면에 뿌려주는데 커널이 하도록 할 수 있다. stty -tabs는 커널이 탭을 공백문자로 바꾼다.</p>\n<p style=\"margin-left: 2em;\">개행문자로 마찬가지이다. 012를 캐리지 리턴과 개행으로 확장하여 출력한다. 일부 시스템(windows, joo생각)은 CRLF를 직접 파일에 입력한다. Unix에서는 사용자가 화일에 넣지 않은 어떠한 바이트도 사용하지 않는다.</p>\n<h3>2.2 화일의 내용</h3>\n<p>Unix 에서는 화일은 구별하려는 대신 화일의 차이점을 무시하려고 한다. 모든 화일은 문자와 개행문자로 구성된다. Unix에서는 화일에 접근하기 위해서는 단지 화일 이름만 알면 된다.</p>\n<p>그러나 이것은 문제가 될 수 있다. 이진화일의 경우 개행문자 없이 수만문자가 이어져 나온다. 이 경우 Unix 프로그램은 제대로 수행되지 못한다. 한 줄에 대한 가상의 정의가 되어 있기 때문이다.</p>\n<h3>2.3 디렉토리와 화일명</h3>\n<p>pwd : 현재의 디렉토리를 알려준다.</p>\n<p>du : 한 디렉토리 내의 모든 화일과 모든 부디렉토리가 차지하는 디스크 공간의 양을 알려준다.</p>\n<h3>2.4 접근권한</h3>\n<p>화일에 접근권한을 두어서 다른 사용자가 자신의 화일을 볼 수 없도록 할 수 있다.</p>\n<p>su를 사용해 수퍼유저이 될 수 있다. 이 경우 모든 화일에 접근할 수 있는데 수퍼유저도 볼 수 없는 화일을 만들기 위해 crypt를 사용할 수 있다.</p>\n<p>/etc/passwd : 로그인정보를 포함해 암호정보를 가지고 있다.</p>\n<p>set-uid : 화일권한에 x 대신 s가 있는 것은 화일이 실행되는 순간 그 화일의 소유자의 권한이 되는 것이다. 이것은 매우 유용하지만 잘못 사용하면 보안상의 문제가 생길 수 있다.</p>\n<h3>2.5 i-노드</h3>\n<p>inode에는 세가지 시간이 있다.</p>\n<p style=\"margin-left: 2em;\">최종수정시간 : 쓰여진 시간</p>\n<p style=\"margin-left: 2em;\">최종사용시간 : 읽거나 수행된 시간</p>\n<p style=\"margin-left: 2em;\">최종변경시간 : inode가 변경된 시간</p>\n<p>chmod, chown</p>\n<h3>2.6 디렉토리 계층</h3>\n<p>/bin : binaries</p>\n<p>/dev : devices</p>\n<p>/etc : et cetera</p>\n<h3>2.7 장치</h3>\n<p>/dev 에 있는 화일은 device로 사용되지만 Unix에는 동일하게 화일로 인식된다.</p>\n<h2>3장 쉘의 사용</h2>\n<h3>3.1 명령어 줄의 구조</h3>\n<p>보통은 개행문자가 명령의 끝으로 인식되지만 ; 도 명령의 끝으로 인식된다.</p>\n<p>; 로 구분된 명령을 파이프로 보낼때는 마지막 명령의 결과만이 파이프로 보내진다.</p>\n<p>같이 보내기 위해서는 ()로 묶어주어야 한다.</p>\n<p>tee : 파이프로 흐르는 data를 화일로 저장하고 파이프로 그대로 흘려보낼 수 있다.</p>\n<h3>3.2 메타문자</h3>\n<p>* 과 같은 특수한 특성을 가진 문자</p>\n<p>이들 메타문자가 해석되지 않도록 하기 위해서는 ' 로 감싸주면 된다.</p>\n<p>줄 끝의 역슬래쉬는 그 줄이 다음줄에 계속 연결되는 것을 말한다.</p>\n<p>echo는 명시적으로 요청받지 않아도 최종적으로 개행문자를 출력한다.</p>\n<p style=\"margin-left: 2em;\">echo -n , echo \"....\\c\" : 개행문자를 추가하지 않게 한다.</p>\n<h3>3.3 새 명령어의 생성</h3>\n<p>Unix의 여러가지 명령을 조합하여 새로운 명령을 만들 수 있다.</p>\n<p>실행권한을 주게되면 쉘의 도움없이도 가능하다.</p>\n<h3>3.4 명령어 인수 및 매개변수</h3>\n<p>$1 ... $9 로 입력된 인자와 매개변수를 전달할 수 있다.</p>\n<p>$* : 인자 모두를 뜻한다.</p>\n<p style=\"margin-left: 2em;\">echo 'grep $* /usr/you/lib/phone-book' &gt; 114 로 114 명령을 만들 수 있는데..</p>\n<p style=\"margin-left: 2em;\">114 'john mike' 에는 실제로 mike라는 화일에서 john을 찾는 것으로 해석될 수 있다.</p>\n<p style=\"margin-left: 2em;\">따라서 $* 를 \"$*\" 과 같이 \" 로 감싸줄 필요가 있다.</p>\n<p>$0 : 현재 수행되는 프로그램 이름이다.</p>\n<h3>3.5 인수로서의 프로그램 출력</h3>\n<p>` 로 감싼 부분은 수행된 뒤 그 결과를 반환한다.</p>\n<p>pick : 대화식 명령이 가능하다.</p>\n<h3>3.6 쉘 변수</h3>\n<p>set : 모든 정의된 변수의 값을 알 수 있다. (몇가지를 보기위해서는 echo를 쓰는 것이 더 좋다)</p>\n<p>HOME, PATH 등이 쉘에서 사용된다.</p>\n<p>어떤 변수의 값을 부속쉘에서도 접근가능하게 하려면 export를 쓰면 된다.</p>\n<h3>3.7 I/O 방향전환에 대한 추가 사항</h3>\n<p>&gt; : 표준출력을 다른 곳으로 돌린다.</p>\n<p>2&gt; : 표준에러를 다른 곳으로 돌린다.</p>\n<p>2&gt;&amp;1 : 표준에러를 표준출력과 같은 곳으로 한다.</p>\n<p>&lt;&lt; s : (here docuement) s를 맨앞에 가진 줄 직전까지의 표준입력을 취한다.</p>\n<h3>3.8 쉘 프로그램에서의 반복문 처리</h3>\n<p>for 변수 in 단어들의 목록</p>\n<p>do</p>\n<p style=\"margin-left: 2em;\">명령어들</p>\n<p>done</p>\n<p>for 변수 in 목록 ; do 명령어들 ; done</p>\n<p>for i in * 과 for i in $* 은 다르게 해석된다. 파일에서 $*로 사용하면 인자를 받아서 따로따로 수행하는 것이다.</p>\n<h3>3.9 bundle : 모두 하나로 묶기</h3>\n<p>bundle은 현재 사용되지 않는다.</p>\n<h3>3.10 왜 하필이면 프로그램이 가능한 쉘인가?</h3>\n<p>쉘은 프로그램으로 처리해야 하는 여러가지 문제를 해결해주기 때문에 이를 사용하는 것이 유익하다.</p>\n<h2>4장 필터</h2>\n<p>sed : stream editor</p>\n<p>awk : 제작자의 이름을 따서 만들었다.</p>\n<h3>4.1 grep 류</h3>\n<p>$ grep 패턴 화일명들 ...</p>\n<p>grep, egrep, fgrep</p>\n<h3>4.2 그 밖의 필터들</h3>\n<p>sort : 입력을 줄 단위로 아스키 순으로 정렬한다.</p>\n<p>uniq : 중복된 줄을 버린다. (-c 로 중복된 횟수를 셀 수 있다)</p>\n<p>comm : 화일을 비교한다.</p>\n<p>tr : 입력의 문자를 변경할 수 있다. (대소문자 변환에 흔히 쓰인다)</p>\n<h3>4.3 스트림 편집기 sed</h3>\n<p>sed 는 ed를 고쳐서 사용되었다.</p>\n<p>$ sed 'ed의 명령어' files...</p>\n<p>명령</p>\n<p style=\"margin-left: 2em;\">'s/A/B/f' : substitute A to B, f=g 이면 모두 바꿈</p>\n<p style=\"margin-left: 2em;\">'y/A/B/' : A스트링을 B스트링으로 바꾸라</p>\n<p style=\"margin-left: 2em;\">-f file : 패턴을 파일로부터 읽어들인다.</p>\n<p style=\"margin-left: 2em;\">-n : 자동 프린트를 하지 않는다. 명시적으로 p를 사용해야 프린트한다.</p>\n<p style=\"margin-left: 2em;\">'/pattern/d' : 매칭되는 줄을 삭제</p>\n<h3>4.4 패턴의 조사 처리 언어 awk</h3>\n<p>$ awk '프로그램' files ...</p>\n<p>프로그램</p>\n<p style=\"margin-left: 2em;\">pattern { action }</p>\n<p>awk는 한번에 한 줄씩 화일명들에서 입력을 읽어들인다.</p>\n<p>필드</p>\n<p style=\"margin-left: 2em;\">awk는 각 입력 줄을 자동으로 필드로 나눈다. $1 .. $NF(마지막 필드)</p>\n<p style=\"margin-left: 2em;\">-F분리자 : 분리자를 지정한다. (FS=\"분리자\" 로도 쓸 수 있다)</p>\n<p>프린트하기</p>\n<p style=\"margin-left: 2em;\">NR : 현제 레코드번호 (= 줄번호)</p>\n<p style=\"margin-left: 2em;\">printf \"format\" : printf 를 사용해 출력할 수 있다.</p>\n<p>패턴</p>\n<p style=\"margin-left: 2em;\">== : 같다.</p>\n<p style=\"margin-left: 2em;\">~ : 문자와 부합된다.</p>\n<p style=\"margin-left: 2em;\">!~ : 문자와 부합되지 않는다.</p>\n<p>BEGIN 및 END 패턴</p>\n<p style=\"margin-left: 2em;\">BEGIN { ... } : 입력을 읽기 전에 수행된다.</p>\n<p style=\"margin-left: 2em;\">END { ... } : 입력을 읽은 후 수행된다.</p>\n<p>산술과 변수 : awk의 진정한 강점은 입력 데이타에 대한 계산이 가능하다는데에 있다.</p>\n<p style=\"margin-left: 2em;\">awk는 C와 동일한 산술연산을 사용할 수 있다.</p>\n<p>awk의 내장 변수</p>\n<p style=\"margin-left: 2em;\">FILENAME : 현재의 입력 화일명</p>\n<p style=\"margin-left: 2em;\">FS : 필드 분리 문자</p>\n<p style=\"margin-left: 2em;\">NF : 입력 레코드 내의 필드 수</p>\n<p style=\"margin-left: 2em;\">NR : 입력 레코드 수</p>\n<p style=\"margin-left: 2em;\">OFMT : 숫자의 출력 포맷</p>\n<p style=\"margin-left: 2em;\">OFS : 출력 필드의 분리 문자열</p>\n<p style=\"margin-left: 2em;\">ORS : 출력 레코드의 분리 문자열</p>\n<p style=\"margin-left: 2em;\">RS : 입력 레코드 분리 문자</p>\n<p>제어흐름</p>\n<p style=\"margin-left: 2em;\">C의 문법과 비슷하나 한 명령의 끝을 개행문자로 한다.</p>\n<p style=\"margin-left: 2em;\">next : 다음 입력 줄을 불러들인다.</p>\n<p style=\"margin-left: 2em;\">exit : END 패턴으로 즉각 넘어간다.</p>\n<p>배열</p>\n<p style=\"margin-left: 2em;\">선언하지않고 배열이 사용이 가능하다.</p>\n<p>awk의 내장함수</p>\n<p style=\"margin-left: 2em;\">cos(expr) : cosine</p>\n<p style=\"margin-left: 2em;\">exp(expr) : 지수</p>\n<p style=\"margin-left: 2em;\">getline() : 다음 입력 줄을 읽고 화일의 끝이면 0, 아니면 1일 반환</p>\n<p style=\"margin-left: 2em;\">index(s1, s2) : s1에서 문자열 s2의 위치, 없으면 0</p>\n<p style=\"margin-left: 2em;\">int(expr) : expr의 정수부, 버림법을 사용한다.</p>\n<p style=\"margin-left: 2em;\">length(s) : 문자열 s의 길이</p>\n<p style=\"margin-left: 2em;\">log(expr) : 자연로그</p>\n<p style=\"margin-left: 2em;\">sin(expr) : sine</p>\n<p style=\"margin-left: 2em;\">split(s, a, c) : s를 문자 c를 기준으로 a[1] ... a[n]으로 분리하고 n을 반환</p>\n<p style=\"margin-left: 2em;\">sprintf(fmt, ...) : fmt에 따른 포맷</p>\n<p style=\"margin-left: 2em;\">substr(s, m, n) : s내의 위치 m에서 시작하는 n 길이의 문자열</p>\n<p>연관배열 : awk는 해쉬를 이용해 연관배열을 사용한다.</p>\n<p>문자열</p>\n<p style=\"margin-left: 2em;\">a = a \" \" : awk에는 문자열 접합연산자가 특별히 없다. 단지 나열만으로 접합이 일어난다.</p>\n<p>쉘과의 대화</p>\n<p style=\"margin-left: 2em;\">awk에서 인자를 받기위해서는 두가지 방식이 있다.</p>\n<p style=\"margin-left: 4em;\">awk '{ print $'$1' }'</p>\n<p style=\"margin-left: 4em;\">awk '{ print \\$$1 }'</p>\n<p style=\"margin-left: 2em;\">따옴표를 사용하는 방법이 더 좋다. \\가 너무 많아지면 복잡해지기 때문이다.</p>\n<p style=\"margin-left: 2em;\">또한 BEGIN을 통해 자주 사용되는 부분을 변수화 해두면 복잡함을 줄일 수 있다.</p>\n<h3>4.5 좋은 화일과 좋은 필터</h3>\n<p>Unix에서 생성하는 출력은 다른 프로그램의 입력으로 쓰일 수 있다.</p>            ","summary":"책을 읽으면서 정리하는 것이 가장 좋은 학습법이라 생각해 정리를 해본다.\n1장 초보자를 위한 Unix\n1.1 출발\n단말기와 타이핑\n제어문자 : ^M (Return 키) ^D (입력 완료) ^G (단말기 벨소리) ^H (후진) ^I (탭)\ntty : teletype, terminal의 동의어\n단말기의 이상동작\nstty : set terminal options\nstty -tabs\n오타\nreturn을 누르기 전 오타발생시 삭제 할 수도 있지만 @을 입력하면 ","image":"https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png"}},"__N_SSG":true}