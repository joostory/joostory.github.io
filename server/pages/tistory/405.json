{"pageProps":{"post":{"id":"405","date":"2016. 1. 29. 20:22","title":"Markdown Editor를 React로 재작성","content":"<p><a href=\"http://codemirror.net\">codemirror</a>에 한참 빠져있을때 간단히 만든 <a href=\"http://dev.joostory.net/markdown\">markdown to html 에디터</a>가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.</p>\n<p>그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던 CommonJS도 알게 되었다. <a href=\"http://blog.joostory.net/404\">react에 webpack을 적용</a>하면서는 눈이 번쩍 뜨이는 것 같았다. 이런 방법이 있는데 왜 그동안 그렇게 고생했던 것일까 싶다. (사실 CommonJS만 알았어도 더 속도가 붙었을 것 같다.)</p>\n<p>지금부터 이전에 만들었던 markdown 에디터를 react와 재작성한 과정을 정리해보려고 한다. 정리를 한번 하면 좀 더 이해한 것이 머리 속에 더 깊이 들어오리라 기대하면서...</p>\n<h2 id=\"header--\">구조</h2>\n<figure><span class=\"imageblock\" style=\"display:inline-block;width:820px;;height:auto;max-width:100%\"><span data-url=\"https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434?download\" data-lightbox=\"lightbox\"><img srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F23695C3856AB4B14343AA8\" src=\"https://t1.daumcdn.net/cfile/tistory/23695C3856AB4B1434\" style=\"cursor: pointer;max-width:100%;height:auto\" width=\"820\" height=\"520\" filename=\"스크린샷 2016-01-29 오후 7.32.21.png\" filemime=\"image/png\" ></span></span></figure>\n<p>구조는 간단하다. 왼쪽에 <em>에디터</em>, 오른쪽에 <em>미리보기</em>가 있고 크기를 조정할 수 있는 <em>칸막이</em>가 있다. <em>에디터</em>에 markdown으로 내용을 입력하면 <em>미리보기</em>에 이를 html로 변환해서 보여준다. <em>Preview탭</em>에는 html을 렌더링해서 보여주고 <em>HTML탭</em>에는 html 코드로 보여준다.</p>\n<pre><code>var Editor = require('./editor');\nvar Divider = require('./divider');\nvar Preview = require('./preview');\n\nvar App = React.createClass({\n\n    ...\n\n    render: function() {\n        return (\n            &lt;div className=\"editor-container\"&gt;\n                &lt;Editor onChange={this.handleChangeEditorValue} /&gt;\n                &lt;Divider /&gt;\n                &lt;Preview value={this.state.value} /&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n\n\nReactDOM.render(\n    &lt;App /&gt;,\n    document.getElementById(\"container\")\n);\n</code></pre><p>react의 좋은 점 중 하나는 이런 식으로 생각한 것을 그대로 코드로 옮기면 된다는 점이다. 이제 <code>Editor</code>와 <code>Divider</code>, <code>Preview</code>를 각각 구현해주면 된다. 각 모듈은 CommonJS 방식으로 로드하기 때문에 webpack 설정에 필요한 파일들을 넣는다.</p>\n<pre><code>module.exports = {\n    entry: {\n        'editor': [\n            path.join(__dirname, 'static/js/editor/app'),\n            path.join(__dirname, 'static/js/editor/editor'),\n            path.join(__dirname, 'static/js/editor/codemirror-editor'),\n            path.join(__dirname, 'static/js/editor/preview'),\n        ]\n    },\n}\n</code></pre><p>webpack에 <code>--watch</code> 옵션을 넣어 실행하면 파일을 수정할때마다 매번 webpack을 실행하는 수고를 하지 않아도 된다.</p>\n<h2 id=\"header-editor\">Editor</h2>\n<pre><code>var CodeMirrorEditor = require('./codemirror-editor');\n\nvar Editor = React.createClass({\n    render: function() {\n        return (\n            &lt;div className=\"editor\"&gt;\n                &lt;EditorHeader /&gt;\n                &lt;CodeMirrorEditor placeholder=\"내용을 입력하세요\" onChange={this.props.onChange} /&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>에디터는 Header때문에 한번 더 감싼 것이고 실제로는 CodeMirrorEditor를 사용하도록 했다.</p>\n<pre><code>var CodeMirror = require('codemirror');\n\nvar CodeMirrorEditor = React.createClass({\n    componentDidMount: function() {\n        this.codeMirror = CodeMirror.fromTextArea(this.refs.textarea, this.props.options);\n        this.codeMirror.on('change', this.handleChange);\n    },\n    componentWillUnmount: function() {\n        if (this.codeMirror) {\n            this.codeMirror.toTextArea();\n        }\n    },\n    handleChange: function(doc) {\n        this.setState({\n            value: doc.getValue()\n        });\n        this.props.onChange(this.state.value);\n    },\n    render: function() {\n        return (\n            &lt;div className=\"editor-content\"&gt;\n                &lt;textarea ref=\"textarea\" placeholder={this.props.placeholder}&gt;{this.props.value}&lt;/textarea&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>CodeMirror는 React Class가 아니기 때문에 <code>componentDidMount</code>와 <code>ref</code>를 사용해서 초기화했다. <a href=\"https://github.com/JedWatson/react-codemirror\">react-codemirror</a>가 있기는 한데 placeholder plugin을 지원하지 않아서 사용하지 않았다. codemirror를 잘 모르는 상태라면 react-codemirror를 사용하는 것도 나쁘지 않을 것 같다.</p>\n<h2 id=\"header-preview\">Preview</h2>\n<pre><code>var marked = require('marked');\nmarked.setOptions({\n    headerPrefix: \"header-\"\n});\n\nvar Preview = React.createClass({\n    render: function() {\n        var style = {\n            left: this.props.position\n        };\n        var value = marked(this.props.value);\n        var html = {\n            __html: value\n        }\n\n        return (\n            &lt;div className=\"preview\" style={style}&gt;\n                &lt;ul id=\"resultTab\" className=\"nav nav-tabs\" role=\"tablist\"&gt;\n                    &lt;li role=\"presentation\" className=\"active\"&gt;&lt;a href=\"#preview\" aria-controls=\"preview\" role=\"tab\" data-toggle=\"tab\"&gt;Preview&lt;/a&gt;&lt;/li&gt;\n                    &lt;li role=\"presentation\"&gt;&lt;a href=\"#html\" aria-controls=\"html\" role=\"tab\" data-toggle=\"tab\"&gt;HTML&lt;/a&gt;&lt;/li&gt;\n                &lt;/ul&gt;\n\n                &lt;div className=\"tab-content\"&gt;\n                    &lt;div ref=\"preview\" id=\"preview\" role=\"tabpanel\" className=\"tab-pane result_preview active\" dangerouslySetInnerHTML={html}&gt;&lt;/div&gt;\n                    &lt;textarea ref=\"rawPreview\" id=\"html\" role=\"tabpanel\" className=\"tab-pane result_html\" readonly=\"readonly\" value={value}&gt;&lt;/textarea&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>미리보기에는 markdown to html을 해주는 라이브러리를 사용했는데 <a href=\"https://github.com/chjj/marked\">marked</a>를 사용했다. react-marked라는 것도 있던데 그건 결과가 react class라서 marked를 사용했다. html을 render해야해서 어쩔 수 없이 <code>dangerouslySetInnerHTML</code>를 사용했다.</p>\n<h2 id=\"header--\">마치며</h2>\n<p>react는 UI를 구조화할 수 있게 해주고 CommonJS는 소스코드를 구조화할 수 있게 해준다. 이 둘이 있어서 너무 좋다. 그동안 왜 이걸 안썼는지, 아니 왜 몰랐는지... 바보가 되는 것은 참 쉽다는 생각이 들었다. 가만히 있으면 바보가 된다. 늘 공부하며 살아야겠다.</p>\n<p>지금까지 정리한 것은 <a href=\"http://dev.joostory.net/markdown\" target=\"_blank\" class=\"tx-link\">이전에 만들었던 것</a>을 <a href=\"http://dev.joostory.net/editor\" target=\"_blank\" class=\"tx-link\">재작성한 것</a>이고 이제는 추가하려고 했던 기능을 넣어보려고 한다. 오랜만에 두근두근 한다.</p>            ","summary":"codemirror에 한참 빠져있을때 간단히 만든 markdown to html 에디터가 있다. 여기에 tistory api로 글 보내기도 붙이고 글 가져오기, 로컬에 임시 저장하기 등등을 붙여보고 싶었는데 솔직히 말해서 엄두가 나지 않았다. 아무래도 코드가 길어질테니 파일을 분리하는 것이 관리하기 편할텐데 분리한 모듈을 관리하고 merge해서 테스트하고 하는 과정이 굉장히 번거롭게 느껴졌다.\n그러다가 react 공부하게 되었고, 부끄럽게도 아직 몰랐던","image":"https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F23695C3856AB4B1434"}},"__N_SSG":true}