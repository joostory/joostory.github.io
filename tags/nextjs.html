<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><meta name="theme-color" content="#000" data-next-head=""/><link rel="shortcut icon" href="/favicon.ico" data-next-head=""/><title data-next-head="">JooStory.net</title><meta name="description" content="소프트웨어 개발을 하고 있는 Joo입니다." data-next-head=""/><meta property="og:type" content="website" data-next-head=""/><meta property="og:title" content="JooStory.net" data-next-head=""/><meta property="og:description" content="소프트웨어 개발을 하고 있는 Joo입니다." data-next-head=""/><meta property="og:image" content="https://joostory.net/assets/og.png" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="JooStory.net" data-next-head=""/><meta name="twitter:description" content="소프트웨어 개발을 하고 있는 Joo입니다." data-next-head=""/><meta property="twitter:image" content="https://joostory.net/assets/og.png" data-next-head=""/><link rel="preload" href="/_next/static/css/129d7802a9c44934.css" as="style"/><link rel="stylesheet" href="/_next/static/css/129d7802a9c44934.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-fed21fd4fa8ebdd4.js" defer=""></script><script src="/_next/static/chunks/framework-5d4a7a9e7f179260.js" defer=""></script><script src="/_next/static/chunks/main-61e0f690081c68d9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-dd723e9e27017ab7.js" defer=""></script><script src="/_next/static/chunks/695-7a801658c6295d16.js" defer=""></script><script src="/_next/static/chunks/784-5a65669942ef1610.js" defer=""></script><script src="/_next/static/chunks/587-cb4bb4b996c79932.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Btag%5D-fec9a11e08004ac8.js" defer=""></script><script src="/_next/static/wVuwOY5dBdu0vOpKKL9Wq/_buildManifest.js" defer=""></script><script src="/_next/static/wVuwOY5dBdu0vOpKKL9Wq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><div class="hero pt-36 pb-24"><div class="flex justify-center items-center"><h1 class="text-3xl font-bold">Tags: <!-- -->nextjs<!-- --> (<!-- -->2<!-- -->)</h1></div></div><div class="divider"></div><div class="mt-6 mb-16 mx-6"><div class="max-w-prose mx-auto"><section><div><div class="py-6"><div><a class="group flex space-x-5" href="/posts/react-router-to-nextjs"><div class="flex-1"><strong class="group-hover:text-yellow-600 text-xl leading-8 text-slate-300 block">React Router에서 NEXT.js로</strong><p class="text-md leading-relaxed text-slate-400">성경 웹버전을 새롭게 개편했다. 이전에도 github pages를 사용했지만 react-router의 HashRouter대신 NEXT.js가 그 역할을 하도록 했다.</p></div></a><div class="text-xs mt-4"><em class="text-slate-500"><time dateTime="2023-01-13T21:00:00+0900">2023.01.13 12:00</time></em></div></div></div><div class="py-6"><div><a class="group flex space-x-5" href="/posts/hello-world"><div class="flex-1"><strong class="group-hover:text-yellow-600 text-xl leading-8 text-slate-300 block">Hello, World</strong><p class="text-md leading-relaxed text-slate-400">JooStory.net을 새롭게 개편했습니다. 오래 정들었던 텀블러를 떠나 github page로 JooStory.net을 이전하려고 한다. 말이 이전이지 이전에 작성했던 글을 옮겨오지는 않을 것이다. 도메인이 바뀌어서 링크가 모두 깨질텐데 대단한 내용이 있는 것도 아니라서 상관하지 않기로 했다.</p></div></a><div class="text-xs mt-4"><em class="text-slate-500"><time dateTime="2022-04-20T18:21:07+0900">2022.04.20 09:21</time></em></div></div></div></div></section></div></div></main><footer class="footer p-10 text-base-content bg-base-300 place-items-center"><div class="grid grid-flow-col gap-4"><a class="link link-hover" href="/">Index</a><a class="link link-hover" href="/profile">About</a><a class="link link-hover" href="/tags">Tags</a><a class="link link-hover" href="https://blog.joostory.net">Blog</a></div><div class="grid grid-flow-col gap-4"><a href="https://twitter.com/JooStory"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="fill-current"><path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"></path></svg></a><a href="https://github.com/joostory"><svg width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fill-current"><path d="M256,32C132.3,32,32,134.9,32,261.7c0,101.5,64.2,187.5,153.2,217.9a17.56,17.56,0,0,0,3.8.4c8.3,0,11.5-6.1,11.5-11.4,0-5.5-.2-19.9-.3-39.1a102.4,102.4,0,0,1-22.6,2.7c-43.1,0-52.9-33.5-52.9-33.5-10.2-26.5-24.9-33.6-24.9-33.6-19.5-13.7-.1-14.1,1.4-14.1h.1c22.5,2,34.3,23.8,34.3,23.8,11.2,19.6,26.2,25.1,39.6,25.1a63,63,0,0,0,25.6-6c2-14.8,7.8-24.9,14.2-30.7-49.7-5.8-102-25.5-102-113.5,0-25.1,8.7-45.6,23-61.6-2.3-5.8-10-29.2,2.2-60.8a18.64,18.64,0,0,1,5-.5c8.1,0,26.4,3.1,56.6,24.1a208.21,208.21,0,0,1,112.2,0c30.2-21,48.5-24.1,56.6-24.1a18.64,18.64,0,0,1,5,.5c12.2,31.6,4.5,55,2.2,60.8,14.3,16.1,23,36.6,23,61.6,0,88.2-52.4,107.6-102.3,113.3,8,7.1,15.2,21.1,15.2,42.5,0,30.7-.3,55.5-.3,63,0,5.4,3.1,11.5,11.4,11.5a19.35,19.35,0,0,0,4-.4C415.9,449.2,480,363.1,480,261.7,480,134.9,379.7,32,256,32Z"></path></svg></a></div><div class="text-xs">@Joo</div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"nextjs","posts":[{"slug":"react-router-to-nextjs","title":"React Router에서 NEXT.js로","excerpt":"성경 웹버전을 새롭게 개편했다. 이전에도 github pages를 사용했지만 react-router의 HashRouter대신 NEXT.js가 그 역할을 하도록 했다.","content":"\n나의 애증의 프로젝트 성경앱을 또 고쳤다. 이번에는 웹버전에서 사용했던 React Router를 대신해 NEXT.js를 사용하는 것이다.\n\n## Before\n\n변경 전 성경앱은 react + redux로 구성되어 있었다. 예전 스타일로 작성되어 있긴하지만 동작하는데에는 문제는 없었다.\n\n```javascript\nconst middleware = [createLogger()]\nconst store = createStore(\n  reducer,\n  applyMiddleware(...middleware)\n)\n\ncreateRoot(document.getElementById('root'))\n  .render(\n    \u003cProvider store={store}\u003e\n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  )\n```\n\n라우팅은 react-router의 HashRouter를 사용했다. `#/:vcode/:bcode/:cnum` 처럼 브라우저 해시를 파싱해서 보여줄 페이지를 판단한다. React 만으로는 정적 페이지 생산없이 구현할 수 없으니 어쩔 수 없는 선택이었다.\n\n```jsx\n\u003cHashRouter\u003e\n  \u003cdiv className={classnames('main', {'dark': false})}\u003e\n    \u003cheader\u003e\n      \u003ch1 className=\"title\"\u003e\u003cLink to=\"/\"\u003eHolybible\u003c/Link\u003e\u003c/h1\u003e\n      \u003cul className=\"menu\"\u003e\n        \u003cli\u003e\u003ca href=\"https://play.google.com/store/apps/details?id=net.joostory.holybible\"\u003eDownload\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"https://oh-my-bible.tistory.com\"\u003eAbout\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/header\u003e\n    \u003csection\u003e\n      \u003cRoutes\u003e\n        \u003cRoute path=\"/\" exact={true} element={\u003cVersionList /\u003e} /\u003e\n        \u003cRoute path=\"/:vcode\" exact={true} element={\u003cBookList /\u003e} /\u003e\n        \u003cRoute path=\"/:vcode/:bcode/*\" element={\u003cChapterList /\u003e} /\u003e\n      \u003c/Routes\u003e\n    \u003c/section\u003e\n    \u003carticle\u003e\n      \u003cRoutes\u003e\n        \u003cRoute path=\"/:vcode/:bcode/:chapter\" element={\u003cVerseList /\u003e} /\u003e\n        \u003cRoute path=\"*\" element={\u003cToday /\u003e} /\u003e\n      \u003c/Routes\u003e\n    \u003c/article\u003e\n  \u003c/div\u003e\n\u003c/HashRouter\u003e\n```\n\n사용할 데이터는 public 폴더에 넣어두고 필요할때마다 axios로 요청해서 가져오도록 했다. 역시 정적 페이지 생산없이 구현할 수 있는 가장 편리한 방법이었다.\n\n```javascript\nexport function fetchHolybible(store) {\n\taxios.get('/bible.json')\n\t\t.then(r =\u003e store.dispatch(receiveHolybible(r.data)))\n\t\t.catch(e =\u003e console.log(e))\n}\n\nexport default function App() {\n  const versions = useSelector(state =\u003e state.holybible.versions)\n  // ...\n}\n```\n\n이대로 유지해도 별 문제없지만 나중을 위해서라도 좀 더 최신의 기술을 사용해서 지속가능하도록 유지하고 싶었다. 나중에 '아니, 이런 걸 썼었네' 하며 한숨쉬며 고치고 싶지 않다는 말이다.\n\n\n## After\n\n내가 지금 쓸 수 있는 가장 최신의 기술이라는 것은 NEXT.js다. 원하면 지금처럼 동적으로 페이지를 만들어낼 수도 있고 정적인 페이지를 만들어낼 수도 있다. 데이터 관리는 redux를 그대로 두어도 괜찮겠지만 그래도 좀 더 사용하기 편한 recoil을 적용해보기로 했다. 또, 별로 쓰고 싶지 않았는데 어쩔 수 없이 대세가 되어가는 typescript도 써보기로 했다. 이건 내가 쓸 수 있는 건 아니지만 그래도 어렵지 않게 학습이 가능한 것으로 보았다. tailwind, daisyui도 이 참에 더 확실히 익혀보기로 했다. 뭘 어떻게 할지는 정했으니 적용만 해보면 된다.\n\n\n### NEXT.js, Typescript\n\n가장 먼저 할일은 webpack, react로 구성된 빌드를 NEXT.js로 전환하는 것이었다. 왠지 싫어서 CRA로 사용하지 않고 직접 `webpack.config.js`를 한땀한땀 만들었었다.\n\n```javascript\n// webpack.config.js\nconst config = {\n  entry: {\n    'holybible': './src/index.js'\n  },\n\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'js/[name].min.js'\n  }\n}\n```\n\n요즘 CRA도 마찬가지지만 NEXT.js는 크게 설정할 것이 없다. 기본적으로 정해진 `components`, `pages`, `public`과 같은 폴더 구조에 적절한 파일을 위치해주면 된다. 내가 해준 것은 기본 root를 `src`로 사용하기 위해서 `tsconfig.js`에 `\"baseUrl\":\"src\"` 를 추가해준 것 뿐이다. 나머지는 create next app을 통해 만들어진 것을 그대로 두었다.\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\",\n  }\n}\n```\nreact-router의 HashRouter가 하던 일은 폴더구조를 통해 해결한다. NEXT.js에서 폴더를 `[version]`과 같은 형태로 만드는 것으로 그 하위의 `index.tsx`에서 `params.version`과 같이 바인딩된 값을 가져올 수 있다.\n\n```\n/pages\n├─ /_app.tsx\n├─ /_document.tsx\n├─ /index.tsx\n├─ /[version]\n├─ └ index.tsx\n├─ /[version]/[bible]\n├─ └ index.tsx\n├─ /[version]/[bible]/[chapter]\n│  └ index.tsx\n```\n\n여기까지만 하면 이전에 사용하던 코드를 그대로 재사용해도 문제없이 동작한다. 그런데 나는 typescript를 제대로 사용하기로 했기 때문에 언제까지고 typescript를 js 스타일로 사용할 수는 없다. 그래서 type이 없다고 아우성치는 코드에 type을 지정해주기 시작했다.\n\n\n```typescript\n// domain/bible.ts\nexport interface Version {\n  name: string,\n  vcode: string\n}\n\nexport interface Bible {\n  bcode: number,\n  chapterCount: number,\n  name: string,\n  type: string,\n  vcode: string\n}\n\nexport interface Verse {\n  vcode: string,\n  bcode: number,\n  cnum: number,\n  vnum: number,\n  content: string\n}\n\n// components/VersionList.tsx\ntype VersionListProps = {\n  versions: Array\u003cVersion\u003e\n}\n\nexport default function VersionList({versions}: VersionListProps) {\n  return (\n    \u003cul className=\"menu p-4\"\u003e\n      {versions.map(v =\u003e\n        \u003cli key={v.name}\u003e\n          \u003cLink href={`/${v.vcode}`}\u003e{v.name}\u003c/Link\u003e\n        \u003c/li\u003e\n      )}\n    \u003c/ul\u003e\n  )\n}\n```\n\ntypescript를 잘 모르니 일단은 이 정도로 하기로 했다. 나중에 복잡한 로직을 다루게 된다면 더 많은 경험을 쌓을 수 있겠지만 여기서는 이 정도밖에 수정할 곳이 없었다. 이렇게만 해도 vscode가 에러와 서제스트를 확실히 해줘서 아주 편했다. 일단 수정할때 오류가 미리 표시되는 점이 편한 것 같다. 물론 js만 사용할 때는 없던 type 코드가 생기긴했지만 그래도 간단한 앱이니까 그리 많다고 느껴지지는 않았다. \n\n\n### tailwindcss + daisyui\n\ntailwindcss는 뭔가 bootstrap이 생각나는 방식이라 아직도 그리 좋아하지는 않지만 이거보다 좋은 것이 지금은 없는 것 같다. 아무래도 디자인 능력이 없는 자에게는 미리 만들어진 디자인을 사용할 수 있는 것이 최고인 것 같다. 내가 만든 어떤 것보다 tailwind와 daisyui가 기본 제공해주는 것이 세련되고 심플하고 예쁜 것 같다.\n\n그래서 NEXT.js에 tailwind는 어떻게 적용하느냐? 너무나 간단하다. `postcss.config.js`, `tailwind.config.js`설정하고 기본 css만 import 해주면 된다. 이렇게 `daisyui`까지 설정이 끝난다.\n\n```javascript\n// postcss.config.js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n\n// tailwind.css.js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [\n    require(\"@tailwindcss/typography\"),\n    require('daisyui')\n  ],\n}\n\n// _app.tsx\nimport 'styles/globals.css'\n\nexport default function App() { /* ... */ }\n\n// styles/globals.css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n여전히 class 를 나열하는 건 맘에 안들지만 그래도 별거 하지도 않았는데도 Layout을 비롯해 대부분의 디자인이 끝나버리는 점은 편하다. `md:`와 같은 prefix로 반응형 디자인도 모두 처리해주니 불평이 쏙 들어간다.\n\n```typescript\nfunction Content({ children }: ContentProps) {\n  return (\n    \u003cdiv className=\"absolute inset-0 md:left-60 overflow-y-auto font-serif\"\u003e\n      { children }\n    \u003c/div\u003e\n  )\n}\n\nfunction Sidebar({ children }: SidebarProps) {\n  return (\n    \u003cdiv className=\"absolute inset-0 md:right-auto md:w-60 overflow-y-auto bg-base-200 bg-content\"\u003e\n      { children }\n    \u003c/div\u003e\n  )\n}\n\nfunction Layout({ children }: LayoutProps) {\n  const theme = useRecoilValue(themeState)\n\n  return (\n    \u003cdiv className='h-screen flex flex-col' data-theme={theme}\u003e\n      \u003cHeader /\u003e\n      \u003cdiv className='fixed top-16 bottom-0 left-0 right-0'\u003e\n        { children }\n      \u003c/div\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n### getStaticProps, getStaticPaths\n\nredux -\u003e recoil로의 전환은 물론 처음에는 했었다. 그런데 내가 잊고 있었던 것이 나는 이 모든 페이지를 정적페이지로 만들어야 한다. 그래서 `[version]`과 같은 바인딩을 사용하는 부분이 렌더링 코드에 들어가면 안된다. 모든 것은 `getStaticProps`를 통해서 만들어져서 component에 전달되고 component는 그저 전달된 값을 사용해야한다.\n\n```typescript\nexport default function VersionPage() {\n  const router = useRouter()\n  const vcode: string = router.query.version? router.query.version.toString() : \"\"\n  const versions: Version[] = useRecoilValue(bibleState)\n  const version = versions.find(v =\u003e v.vcode == vcode)\n\n  return (\n    \u003c\u003e...\u003c/\u003e\n  )\n}\n```\n\n`/GAE`와 같은 요청을 받아들이려면 정적 사이트는 `/GAE.html`와 같은 파일을 준비하고 있어야 한다. 무슨 `router.query`란 말인가? 이것은 next 서버를 사용할 때나 가능한 방법이다. 정적 페이지로 export하기 위해서는 다음과 같이 서버 사이드 처리가 완료되었다고 가정해야하고 이 서버 사이드처리는 `getStaticProps`가 빌드 단계에서 미리 수행해야한다. `version`뿐만 아니라 `BibleList`에서 사용할 `bibles`까지도 이 단계에서 다 가져와야만 한다.\n\n```typescript\nexport async function getStaticProps({ params }: any) {\n  const version = getVersion(params.version)\n\n  return {\n    props: {\n      version: version,\n      bibles: getBibles(version.vcode)\n    }\n  }\n}\n\ntype VersionPageProps = {\n  version: Version,\n  bibles: Bible[]\n}\n\nexport default function VersionPage({ version, bibles }: VersionPageProps) {\n  return (\n    \u003c\u003e...\u003c/\u003e\n  )\n}\n```\n\n이런 식의 변경이 완료되자 더이상 recoil이 할 일이 없다. recoil이 할 일은 theme관리 뿐이다. 앞으로 브라우저에 값을 저장하던가 하는 등 뭔가 더 있을 수도 있겠지만 현재로서는 그렇다. 사실 지금은 하는 일이 없다고 봐도 무방하다.\n\n\n## 마치며\n\n![](/assets/posts/react-router-to-nextjs/holybible_01.jpeg)\n\n언제까지고 이런 static page만 만들지는 않을 것이다. 최근 같이 작업했던 사내 FE 개발자가 NEXT.js로 웹서버를 만드는 것을 보았다. 이전에는 이들을 위해서 내가 서버를 만들어주어야 했다. 그런 걸 할 수 있다면 다른 것도 다 할 수 있겠다는 생각이 들었다. 인증처리만 해결된다면 굳이 별도의 서버없이 NEXT.js 만으로 어드민 서버를 만든다거나 웹서버를 구성하는 것이 가능할 거다. 물론 이미 그게 가능한지는 오래되었지만 내가 이제야 알았고 이제는 그것을 할 맘의 준비가 되었다는 뜻이다.\n\n시간이 가면 갈수록 배워야하는 것이 점점 더 많아지는 것 같다. 예전에는 차근차근하다보면 언젠간 마스터가 될 수 있을거라 생각했는데 지금은 그 길이 점점 멀어지는 것만 같다. 이렇게라도 조금씩 조금씩 따라가는 수밖에... 그리고 이런 기술은 어디까지나 나의 사이드 기술이고 나는 메인 기술인 devops를 지향해야한다. 하고 싶은 것은 많은데 나에게 남은 시간은 점점 줄어가고 나는 또 게임이나 하고 영화나 보고 있다. (주절주절)\n","tags":["nextjs"],"date":"2023-01-13T21:00:00+0900","author":{"name":"Joo","picture":"/assets/profile.jpg"},"ogImage":{"url":"https://joostory.net/assets/posts/react-router-to-nextjs/cover.png"},"coverImage":null},{"slug":"hello-world","title":"Hello, World","excerpt":"JooStory.net을 새롭게 개편했습니다. 오래 정들었던 텀블러를 떠나 github page로 JooStory.net을 이전하려고 한다. 말이 이전이지 이전에 작성했던 글을 옮겨오지는 않을 것이다. 도메인이 바뀌어서 링크가 모두 깨질텐데 대단한 내용이 있는 것도 아니라서 상관하지 않기로 했다.","content":"\n오래 정들었던 텀블러를 떠나 github page로 JooStory.net을 이전하려고 한다. 말이 이전이지 이전에 작성했던 글을 옮겨오지는 않을 것이다. 도메인이 바뀌어서 링크가 모두 깨질텐데 대단한 내용이 있는 것도 아니라서 상관하지 않기로 했다. 텀블러, 티스토리에서 개인 웹사이트를 꾸미기 위해서 많은 노력을 했는데 직접 고쳐쓰지 않는한 한계가 있는 것 같다. (티스토리에서 직접 내가 필요한 기능을 만들땐 참 좋았다)\n\n## Github Page\n\n직접 서버를 구성하거나 무료 호스팅을 사용하거나 혹은 유료 호스팅을 사용하는 방법도 생각해봤는데 일단은 github page를 사용하기로 했다. 이제는 언제든 옮겨가서 도메인만 붙이면 되니까... 그리고 ms의 github는 개인 사용자에게 갑자기 돈을 달라고 해서 부담을 줄 것 같지는 않다.\n\n## NextJS\n\nReact로 웹사이트를 만들 수 있다기에 gatsby를 한동안 살펴봤는데 아무래도 graphql과 하나가 된 모습이 그리 익숙해지지 않았다. 아직 내가 graphql을 받아들이기엔 준비가 안된 것 같다. 그러다가 nextjs를 봤는데 이건 뭐 너무 편안했다. 단순한 방식으로 데이터를 조회할 수 있어서 내가 편안한 방식을 사용할 수 있었다. \n\ntheme 같은 것은 아직 잘모르기도하고 익숙해지고 싶기도 해서 일단은 직접 다 만들어볼 예정이다. 익숙해지면 다른 것을 자연스럽게 활용할 수도 있지 않을까 싶다.\n","tags":["nextjs"],"date":"2022-04-20T18:21:07+0900","author":{"name":"Joo","picture":"/assets/profile.jpg"},"ogImage":{"url":"https://joostory.net/assets/posts/hello-world/cover.png"},"coverImage":null}]},"__N_SSG":true},"page":"/tags/[tag]","query":{"tag":"nextjs"},"buildId":"wVuwOY5dBdu0vOpKKL9Wq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>